{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.js","src/model.js","src/query.js","src/store.js","src/util.js"],"names":[],"mappings":"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","file":"updraft.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar Updraft = {\r\n  VERSION : '0.4.0',\r\n  Store : require('./store')\r\n};\r\n\r\nmodule.exports = Updraft;\r\n\r\nif (window) {\r\n  window.Updraft = Updraft;\r\n}\r\n","'use strict';\n\nvar util = require('./util');\nvar Query = require('./query');\n\n\n\n/**\n * Instances of this type will have properties for all the columns defined in its {@link Model}.\n * You can add additional properties, but they will not be saved.  Object will track which properties have changed\n * since the last save.  Fields of type 'ptr' will return an object { [table's key]:[value], get: [function returning promise evaluating to object] }\n * \n *  Do not create objects of type Instance directly; instead create instances of a Model created by {@link Store#createClass}\n *\n * @see Model\n * @class\n * @example\n *  var store = new Updraft.Store();\n *  var Model = store.createClass(...);\n *  var i = new Model(); // i is an Instance\n */\nfunction Instance(props) {\n  var o = this;\n  o._changes = 0;\n  Object.keys(this.model.columns).forEach(function(col) {\n    if(o.model.columns[col].type === 'list') {\n      o['_' + col] = [];\n\n      // allow client to do object.field.push(otherobject); we'll transform it to object.field.push(otherobject.key())\n      o['_' + col].push = function() {\n        var args = Array.prototype.slice.call(arguments).map(function(arg) {\n          if(typeof arg === 'object') {\n            return arg.key();\n          } else {\n            return arg;\n          }\n        });\n        var array = o['_' + col];\n        var ret = Array.prototype.push.apply(array, args);\n        o[col] = array; // this will mark it dirty\n        return ret;\n      };\n    }\n  });\n  props = props || {};\n  for (var key in props) {\n    o[key] = props[key];\n  }\n}\n\n\n/**\n * Return the object's primary key's value\n *\n * @returns {string} Value of primary key\n * @example\n *  var x = new Class();\n *  x.id = 123;\n *  console.log(x.key());\n *  // -> '123'\n */\nInstance.prototype.key = function() {\n  var key = '_' + this.model.key;\n  console.assert(key in this);\n  return this[key];\n};\n\n\n\n/**\n * Get the fields that have been changed since the object was last loaded/saved\n *\n * @returns {string[]} Names of the fields that have changed\n * @example\n *  var x = new Class();\n *  x.foo = 'bar';\n *  console.log(x.changes());\n *  // -> ['foo']\n */\nInstance.prototype.changes = function () {\n  var changes = [];\n  var propIdx = 0;\n  for (var col in this.model.columns) {\n    var propMask = (1 << propIdx++);\n    if (this._changes & propMask) {\n      changes.push(col);\n    }\n  }\n  return changes;\n};\n\n\n\nvar addClassProperty = function(model, proto, col, propMask) {\n  var prop = '_' + col;\n\n  switch(model.columns[col].type) {\n    default:\n      Object.defineProperty(proto, col, {\n        get: function () {\n          return this[prop];\n        },\n        set: function (val) {\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'ptr':\n      Object.defineProperty(proto, col, {\n        get: function () {\n          var ref = this.model.columns[col].ref;\n          console.assert(ref.get);\n          var ret = {};\n          ret.ref = ref;\n          ret.own = this;\n          ret[ref.key] = this[prop];\n          ret.get = function () { return this.ref.get(this.own[prop]); };\n          return ret;\n        },\n        set: function (val) {\n          // allow client to do object.field = otherobject; we'll transform it to object.field = otherobject.key()\n          if(typeof val === 'object') {\n            val = val.key();\n          }\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'list':\n      Object.defineProperty(proto, col, {\n        get: function() {\n          return this[prop];\n        },\n        set: function(val) {\n          // allow client to do object.field = [otherobject]; we'll transform it to object.field = [otherobject.key()]\n          val = val.map(function(arg) {\n            if(typeof arg === 'object') {\n              return arg.key();\n            } else {\n              return arg;\n            }\n          });\n          this[prop] = val;\n          this._changes |= propMask;\n        }\n      });\n      break;\n  }\n};\n\n\n\n/**\n * A class that you can use to create, save, and retrieve {@link Instance}s.\n * Do not create instances of type Model directly; instead use {@link Store#createClass}\n *\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\n * @property {string} key - the name of the primary key for this table\n * @property {columnType} keyType - the type of the primary key for this table\n * @property {Object} columns - an object describing the fields of objects of this type\n * @property {string} columns.key - name of the field\n * @property {object} columns.value\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\n * @property {bool} [columns.value.index=false] - create an index on this field\n * @property {Query} all - use to construct a query\n * @see ExampleModel\n * @class\n * @param {Store} store\n * @param {ClassTemplate} templ\n * @example\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *  \n *  var x = new ExampleModel({keyField: 123});\n */\nfunction Model(store, templ) {\n  console.assert(store);\n  console.assert(templ);\n  console.assert(templ.tableName);\n  console.assert(templ.tableName[0] !== '_');\n  console.assert(templ.columns);\n  console.assert(Object.keys(templ.columns).length < 64);\n  console.assert(!('changes' in templ.columns));\n  console.assert(!('template' in templ.columns));\n  console.assert(!templ.renamedColumns || Object.keys(templ.renamedColumns).every(function (old) { return !(old in templ.columns); }));\n  \n  var ModelInstance = function() {\n    Instance.apply(this, arguments);\n  };\n\n  ModelInstance.prototype = Object.create(Instance.prototype);\n  ModelInstance.prototype.constructor = ModelInstance;\n  \n  var m = function(props) {\n    return new ModelInstance(props);\n  };\n\n  Object.setPrototypeOf(m, Model.prototype);\n  \n  Object.defineProperty(ModelInstance.prototype, 'model', { enumerable: true, value: m });\n  Object.defineProperty(ModelInstance.prototype, 'factory', { enumerable: true, value: m });\n\n  m.ModelInstance = ModelInstance;\n  \n  Object.defineProperty(m, 'store', { enumerable: true, value: store });\n  \n  Object.defineProperty(m, 'all', {\n    get: function() {\n      return new Query(this, this.store);\n    }\n  });\n\n  m.indices = [];\n\n  for (var key in templ) {\n    m[key] = util.clone(templ[key]);\n  }\n\n  m.key = null;\n  m.keyType = null;\n\n  var propIdx = 0;\n  for(var col in m.columns) {\n    if (m.columns[col].key) {\n      m.key = col;\n      m.keyType = m.columns[col].type;\n    }\n    if (m.columns[col].index) {\n      m.indices.push([col]);\n    }\n\n    var propMask = (1 << propIdx++);\n    addClassProperty(m, ModelInstance.prototype, col, propMask);\n    if (propIdx >= 63) {\n      throw new Error(\"class has too many columns- max 63\");\n    }\n  }\n\n  console.assert(m.key);\n\n  return m;\n}\n\n\n/**\n * Get a single object from database by its key\n *\n * @param id - value to find in table's primary key\n * @returns {Promise<Instance>} Promise that resolves with element or null if not found\n * @example\n *  Class.get(123).then(function(obj) {\n *    if(obj) {\n *      console.log('found object 123:', obj);\n *    } else {\n *      console.log('object 123 was not in db');\n *    }\n *  });\n */\nModel.prototype.get = function (id) {\n  return this.all.where(this.key, '=', id).get()\n  .then(function(results) {\n    console.assert(results.length < 2);\n    if(results.length === 0) {\n      return null;\n    } else {\n      return results[0];\n    }\n  });\n};\n\n\n/**\n * construct object from a database result row\n *\n * @param {SQLRow} row\n * @return instance of Model with fields initialized according to row, with _isInDb=true and no changes set\n * @private\n */\nModel.prototype.constructFromDb = function(row) {\n  var o = new this.ModelInstance();\n  for(var col in row) {\n    var val = row[col];\n    var _col = '_' + col;\n    switch(this.columns[col].type) {\n      case 'json':\n        o[_col] = JSON.parse(val);\n        break;\n      case 'list':\n        o[_col].push(val);\n        break;\n      default:\n        o[_col] = val;\n        break;\n    }\n  }\n\n  o._isInDb = true;\n  console.assert(o._changes === 0);\n  return o;\n};\n\n\n\n/**\n * Example class, an {@link Instance} returned by {@link Store#createClass}\n *\n * @class\n * @extends Instance\n * @name ExampleModel\n * @property {int} keyField - object's primary key, unique in the table\n * @property {string} stringField\n * @property {object} jsonField - can be any javascript type, object, or nesting of objects.  Will be \n *           stored stringified, so any shared properties will no longer be shared after reloading from db.\n * @property {int} indexedField - a regular integer field, but queries testing indexed fields will be faster.\n *           Doesn't have to be <tt>int</tt>- any field type can be indexed.\n * @property childField - a pseudo 'ChildClass' object.  Although you can assign to it, the object won't be available.\n *           That is, you will always need to call 'childField.get()' and wait for the promise, even if you just\n *           assigned to it.\n * @property {int} childField.id - the key of the child object pointed to.  Note that the member 'id' is because \n *           ChildClass's key is named 'id'; similarly the type is inherited from ChildClass's key type.  This \n *           is the only part of the reference that is stored on the object.\n * @property {list} listField - a searchable collection of objects\n * @see ClassTemplate, Model\n * @example\n *  var ChildClass = store.createClass({\n *    tableName: 'childClass',\n *    columns: {\n *      id: { type: 'int', key: true },\n *      intField: { type: 'int', index: true }\n *    }\n *  });\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *\n *  var child = new ChildClass({id: 321, intField: 456});\n *\n *  var x = new ExampleModel();\n *  x.keyField = 123;\n *  x.stringField = 'string example';\n *  x.jsonField = { x: 1, y: 'a', z: { foo: 'bar' } };\n *  console.log(x.changes());\n *  // -> ['keyField', 'stringField', 'jsonField']\n *\n *  // the following lines are exactly equivalent:\n *  x.childField = child;\n *  x.childField = child.id;\n *  x.childField = 321;\n *\n *  console.log(x.childField.id); // -> 321\n *\n *  x.childField.get().then(function(c) {\n *    // child was never saved, so c is null, unless there was\n *    // already a ChildClass with id=321 in the db');\n *  });\n *\n *  // ... assume more objects have been created and saved ...\n *\n *  ExampleModel.all.where('childField.intField', '=', 456).get()\n *  .then(function(results) {\n *    // results is an array containing (a copy of) x and anything\n *    // else that has the same \n *  });\n */\n\n\nmodule.exports = Model;\n","'use strict';\n\n\n/**\n * Do not construct objects of type Query directly- instead, use {@link Model}.all\n * @class\n * @constructor\n * @param {Model} model\n * @param {Store} store\n */\nvar Query = function(model, store) {\n  console.assert(model);\n  console.assert(store);\n  this._model = model;\n  this._store = store;\n  this._justCount = false;\n  this._tables = [model.tableName];\n  this._columns = [];\n  this._conditions = [];\n  this._order = undefined;\n  this._limit = undefined;\n  this._offset = undefined;\n  this._asc = true;\n  this._nocase = false;\n\n  // add child tables\n  for(var col in model.columns) {\n    if(model.columns[col].type !== 'list') {\n      this._columns.push(model.tableName + '.' + col);\n    }\n  }\n};\n\n\nQuery.prototype.all = function() {\n  return this.get();\n};\n\n\nQuery.prototype.addCondition = function(conj, col, op, val) {\n  var fields = col.split(/\\./);\n    var f = this._model;\n    for(var i=0; i<fields.length - 1; i++) {\n      var field = fields[i];\n      console.assert(field in f.columns);\n      var ref = f.columns[field].ref;\n      console.assert(ref);\n      if(this._tables.indexOf(ref.tableName)) {\n        this._tables.push(ref.tableName);\n        this._conditions.push({\n          conj: 'AND',\n          col: f.tableName + '.' + field,\n          op: '=',\n          val: ref.tableName + '.' + ref.key\n        });\n      }\n      f = ref;\n    }\n    this._conditions.push({\n      conj: conj,\n      col: f.tableName + '.' + fields[fields.length - 1],\n      op: op,\n      val: '?',\n      arg: val\n    });\n  return this;\n};\n\n\n/**\n * Adds an 'AND' condition to the query\n *\n * @method\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#or\n * @example\n *  return Class.all.where('col2', '>', 10).and('col2', '<', 30).get();\n *  // -> SELECT ... WHERE col2 > 10 AND col2 < 30\n */\nQuery.prototype.and = function(col, op, val) {\n  return this.addCondition('AND', col, op, val);\n};\n\n\n/**\n * alias for {@link Query#and}\n *\n * @method\n * @return {Query}\n * @example\n *  return Class.all.where('col2', '>', 10).get();\n */\nQuery.prototype.where = Query.prototype.and;\n\n\n/**\n * Adds an 'OR' condition to the query\n *\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#and\n * @example\n *  return Class.all.where('col2', '=', 10).and('col2', '=', 30).get();\n *  // -> SELECT ... WHERE col2 = 10 OR col2 = 30\n */\nQuery.prototype.or = function(col, op, val) {\n  return this.addCondition('OR', col, op, val);\n};\n\n\n/**\n * Sort the results by specified field\n *\n * @param {string} col - column to sort by\n * @param {bool} [asc=true] - sort ascending (true, default) or descending (false)\n * @return {Query}\n * @see Query#nocase\n * @example\n *  return Class.all.order('x').get();\n *  // -> SELECT ... ORDER BY x\n */\nQuery.prototype.order = function(col, asc) {\n  this._order = col;\n  if(typeof asc !== 'undefined') {\n    this._asc = asc;\n  }\n  return this;\n};\n\n/**\n * Changes the match collation to be case-insensitive.  Only applies to result sorting, as 'LIKE' is \n * always case-insensitive\n *\n * @return {Query}\n * @see Query#order\n * @example\n *  return Class.all.order('x').nocase().get();\n *  // -> SELECT ... ORDER BY x COLLATE NOCASE\n */\nQuery.prototype.nocase = function() {\n  this._nocase = true;\n  return this;\n};\n\n\n/**\n * Limits the result set to a certain number.  Useful in pagination\n *\n * @return {Query}\n * @see Query#offset\n * @example\n *  return Class.all.limit(5).get();\n *  // -> SELECT ... FROM ... LIMIT 5\n */\nQuery.prototype.limit = function(count) {\n  this._limit = count;\n  return this;\n};\n\n\n/**\n * Skip a number of results.  Useful in pagination\n *\n * @return {Query}\n * @see Query#limit\n * @example\n *  return Class.all.limit(10).offset(50).get();\n *  // -> SELECT ... FROM ... LIMIT 10 OFFSET 50\n */\nQuery.prototype.offset = function(count) {\n  this._offset = count;\n  return this;\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the count of objects that match\n *\n * @return {Promise<int>}\n * @see Query#get\n * @example\n *  return Class.all.count()\n *  .then(function(count) { console.log(count + \" objects\") });\n *  // -> SELECT COUNT(*) FROM ...\n */\nQuery.prototype.count = function() {\n  this._justCount = true;\n  return this.get();\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the array of objects that match any conditions\n * set on the Query\n *\n * @return {Promise<Instance[]>}\n * @see Query#count\n * @example\n *  return Class.all.where('x', '>', 0).get();\n *  // -> SELECT ... WHERE x > 0\n */\nQuery.prototype.get = function() {\n  var countProp = 'COUNT(*)';\n  var stmt = 'SELECT ';\n  var model = this._model;\n  if(this._justCount) {\n    stmt += countProp;\n  } else {\n    stmt += this._columns.join(', ');\n  }\n  stmt += ' FROM ' + this._tables.join(', ');\n  var args = [];\n  for(var i=0; i<this._conditions.length; i++) {\n    var cond = this._conditions[i];\n    stmt += (i === 0) ? ' WHERE ' : (' ' + cond.conj + ' ');\n    stmt += cond.col + ' ' + cond.op + ' ' + cond.val;\n    if('arg' in cond) {\n      args.push(cond.arg);\n    }\n  }\n  if(this._order) {\n    stmt += ' ORDER BY ' + this._order;\n    stmt += (this._nocase ? ' COLLATE NOCASE' : '');\n    stmt += (this._asc ? ' ASC' : ' DESC');\n  }\n  console.assert(!this._offset || this._limit);\n  if(this._limit) {\n    stmt += ' LIMIT ' + this._limit;\n    if(this._offset) {\n      stmt += ' OFFSET ' + this._offset;\n    }\n  }\n\n  var objects = [];\n  var query = this;\n  return this._store.execRead(stmt, args, function (tx, results) {\n    if(query._justCount) {\n      return results.rows.item(0)[countProp];\n    }\n    for (var i = 0; i < results.rows.length; i++) {\n      var o = model.constructFromDb(results.rows.item(i));\n      objects.push(o);\n    }\n    return Promise.all(objects.map(function(o) {\n      return Promise.all(\n        Object.keys(model.columns)\n        .filter(function(col) {\n          return (model.columns[col].type === 'list');\n        })\n        .map(function(col) {\n          var listTable = model.columns[col].listTable;\n          console.assert(listTable);\n          var key = o.key();\n          var s = 'SELECT ' + col;\n          s += ' FROM ' + listTable.tableName;\n          s += ' WHERE ' + query._model.key + ' = ?';\n          return query._store.exec(tx, s, [key], function(tx, results) {\n            for(var i=0; i<results.rows.length; i++) {\n              var row = results.rows.item(i);\n              o['_' + col].push(row[col]);\n            }\n            o._changes = 0;\n          });\n        })\n      );\n    }))\n    .then(function() {\n      return objects;\n    });\n  });\n};\n\n\nmodule.exports = Query;\n","'use strict';\n\nvar util = require('./util');\nvar Model = require('./model');\nvar clone = util.clone;\nvar startsWith = util.startsWith;\n\n\n/**\n * Column types.  Ignore the values; only use the keys.  Note that these are just column\n * affinities, and technically any value type can be stored in any column type.\n * see {@link https://www.sqlite.org/datatype3.html}\n *\n * @enum {string}\n * @readonly\n */\nvar columnType = {\n  'int': 'INTEGER',\n  'bool': 'BOOL',\n  'real': 'REAL',\n  'text': 'TEXT',\n  'blob': 'BLOB',\n  'date': 'DATE',\n  'datetime': 'DATETIME',\n  \n  /** object will be serialized & restored as JSON text */\n  'json': 'TEXT',\n\n  /** points to an object in another table.  Its affinity will be that table's key's affinity */\n  'ptr': 'ref',\n\n  /** list of ptr */\n  'list': 'ref',\n};\n\n\n/**\n * The class template used by {@link Store#createClass}.\n *\n * @typedef\n * @name ClassTemplate\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\n * @property {bool} [recreate=false] - whether the table should be recreated (dropped) if it exists.  All data will be lost.\n * @property {bool} [temp=false] - whether the table should be created as temporary (will not persist)\n * @property {Object} columns - an object describing the fields of objects of this type\n * @property {string} columns.key - name of the field\n * @property {object} columns.value\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\n * @property {bool} [columns.value.index=false] - create an index on this field\n * @property {object} [renamedColumns] - old column name is the key, new column name is the value\n * @example\n *  {\n *    tableName: 'users',\n *    columns: {\n *      'id': { key: true, type: 'int' },\n *      'name': { type: 'text' },\n *      'address3': { type: 'text' }\n *    },\n *    renamedColumns: {\n *      // migrate 'address2' column data into column 'address3'\n *      // the column must be specified in 'columns'\n *      'address2': 'address3'\n *    }\n *  }\n */\n\n\n/**\n * The parameters used to open a database\n *\n * @typedef\n * @name StoreOptions\n * @property {string} name - the name of the database to open\n */\n\n\n/**\n * Interface for creating classes & database interaction\n *\n * @class\n * @property {bool} [logSql=false] - log sql statements to console.log\n */\nvar Store = function () {\n  var self = this;\n  this.tables = [];\n  this.triggers = {};\n  this.logSql = false;\n\n  this.columnType = columnType;\n  \n  /**\n   * create a new type whose instances can be stored in a database\n   * @param {ClassTemplate} templ\n   * @return {Model}\n   * @see ExampleModel\n   * @example \n   *  var ExampleModel = store.createClass({\n   *    tableName: 'exampleModel',\n   *    columns: {\n   *      keyField: { type: 'int', key: true },\n   *      stringField: { type: 'text' },\n   *      jsonField: { type: 'json' },\n   *      indexedField: { type: 'int', index: true },\n   *      childField: { type: 'ptr', ref: ChildClass }\n   *    }\n   *  });\n   */\n  this.createClass = function(templ) {\n    var m = new Model(self, templ);\n    self.tables.push(m);\n    return m;\n  };\n  \n\n  /**\n   * Delete all tables in database.  For development purposes; you probably don't want to ship with this.\n   *\n   * @global\n   * @typedef\n   * @param {StoreOptions} opts\n   * @return {Promise} a promise that resolves when all tables are deleted\n   * @see Store#open\n   * @example\n   *    store.purge({name: 'my cool db'}).then(function() {\n   *      // everything is gone\n   *    });\n   */\n  this.purge = function(opts) {\n    console.assert(!self.db);\n\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\n    console.assert(self.db);\n    return self.readSchema()\n      .then(function(schema) {\n        return new Promise(function(fulfill, reject) {\n          self.db.transaction(function(tx) {\n            var p = Promise.resolve();\n            Object.keys(schema).forEach(function(table) {\n              p = p.then(self.exec(tx, 'DROP TABLE ' + table));\n            });\n            return p.then(function() {\n              self.db = null;\n            })\n            .then(fulfill, reject);\n          });\n        });\n      });\n  };\n\n\n  /**\n   * open the database\n   *\n   * @param {StoreOptions} opts\n   * @return {Promise} a promise that resolves with no parameters when the database is created and ready\n   * @example\n   *    store.open({name: 'my cool db'}).then(function() {\n   *      // start loading & saving objects\n   *    });\n   */\n  this.open = function (opts) {\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\n    console.assert(self.db);\n    \n    // add list tables\n    var listTables = [];\n    for(var i=0; i<self.tables.length; i++) {\n      var table = self.tables[i];\n      for(var col in table.columns) {\n        if(table.columns[col].type === 'list') {\n          var ref = table.columns[col].ref;\n          console.assert(ref);\n          var listTable = {};\n          listTable.tableName = table.tableName + '_' + col;\n          listTable.recreate = table.recreate;\n          listTable.temp = table.temp;\n          listTable.key = '';\n          listTable.keyType = table.keyType;\n          listTable.columns = {};\n          listTable.columns[table.key] = { type: table.keyType }; // note: NOT setting key=true, as it would impose unique constraint\n          listTable.columns[col] = { type: ref.keyType };\n          listTable.indices = [ [table.key], [col] ];\n          table.columns[col].listTable = listTable;\n          listTables.push(listTable);\n        }\n      }\n    }\n    \n    self.tables = self.tables.concat(listTables);\n    \n    return self.readSchema()\n            .then(syncTables);\n  };\n\n\n  /**\n   * close the database\n   */\n  this.close = function () {\n    self.db = null;\n    self.tables = [];\n    self.triggers = {};\n  };\n\n\n  /**\n   * exec a sql statement within a given transaction\n   *\n   * @param {SQLTransaction} tx - a transaction created by <tt>db.transaction</tt> or <tt>db.readTransaction</tt>\n   * @param {string} stmt - sql statement to execute\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\n   * @private\n   */\n  this.exec = function(tx, stmt, args, callback) {\n    if(self.logSql) {\n      console.log(stmt, args);\n    }\n    return new Promise(function (fulfill, reject) {\n      try {\n        tx.executeSql(stmt, args,\n                      function (tx, results) {\n                        var ret = callback ? callback(tx, results) : null;\n                        return Promise.resolve(ret).then(fulfill, reject);\n                      },\n                      function (tx, error) {\n                        reportError(error);\n                        reject(error);\n                      });\n      } catch (reason) {\n        console.log('Failed to exec \"' + stmt + '\":' + reason);\n        throw reason;\n      }\n    });\n  };\n\n\n  /**\n   * exec a sql statement within a new read transaction\n   *\n   * @param {string} stmt - sql statement to execute\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\n   * @private\n   */\n  this.execRead = function(stmt, args, callback) {\n    console.assert(self.db);\n    return new Promise(function (fulfill, reject) {\n      self.db.readTransaction(function (rtx) {\n        return self.exec(rtx, stmt, args, callback)\n                .then(fulfill, reject);\n      });\n    });\n  };\n\n\n  function reportError(error) {\n    switch (error.code) {\n      case error.SYNTAX_ERR:\n        console.log(\"Syntax error: \" + error.message);\n        break;\n      default:\n        console.log(error);\n    }\n  }\n\n\n  /**\n   * Database schema.  The outer keys will be the tables in the database.  The values will consist of an\n   * object whose keys will be the table's rows and values will be the row's type.  It will also have an\n   * '_indices' object with all the indices found.\n   * Note: tables or indices beginning with underscore or 'sqlite' will be ignored\n   *\n   * @typedef\n   * @name Schema\n   * @example\n   *    var schema = {\n   *      'todos': {\n   *        _indices: {\n   *          'index_todos__name': 'CREATE INDEX ...',\n   *        },\n   *        _triggers: {\n   *          'trigger_todos__task': 'CREATE TRIGGER ...',\n   *        },\n   *        'id': 'INTEGER PRIMARY KEY',\n   *        'name': 'TEXT',\n   *      },\n   *      'tasks': {\n   *        'id': 'INTEGER PRIMARY KEY',\n   *        'description': 'TEXT',\n   *      }\n   *    };\n   */\n\n\n  /**\n   * get the existing database's schema in object form\n   *\n   * @return {Promise} a promise that resolves with the {@link Schema}\n   */\n  this.readSchema = function () {\n    function tableFromSql(sql) {\n      var table = { _indices: {}, _triggers: {} };\n      var matches = sql.match(/\\((.*)\\)/);\n      if (matches) {\n        var fields = matches[1].split(',');\n        for (var i = 0; i < fields.length; i++) {\n          var ignore = /^\\s*(primary|foreign)\\s+key/i;  // ignore standalone 'PRIMARY KEY xxx'\n          if (fields[i].match(ignore)) {\n            continue;\n          }\n          var quotedName = /\"(.+)\"\\s+(.*)/;\n          var unquotedName = /(\\w+)\\s+(.*)/;\n          var parts = fields[i].match(quotedName);\n          if (!parts) {\n            parts = fields[i].match(unquotedName);\n          }\n          if (parts) {\n            table[parts[1]] = parts[2];\n          }\n        }\n      }\n      return table;\n    }\n\n    return self.execRead('SELECT name, tbl_name, type, sql FROM sqlite_master', [], function (tx, results) {\n      /*jshint camelcase:false*/\n      var schema = {};\n      for (var i = 0; i < results.rows.length; i++) {\n        var row = results.rows.item(i);\n        if (row.name[0] != '_' && !startsWith(row.name, 'sqlite')) {\n          switch (row.type) {\n            case 'table':\n              schema[row.name] = tableFromSql(row.sql);\n              break;\n            case 'index':\n              schema[row.tbl_name]._indices = schema[row.tbl_name]._indices || {};\n              schema[row.tbl_name]._indices[row.name] = row.sql;\n              break;\n            case 'trigger':\n              schema[row.tbl_name]._triggers = schema[row.tbl_name]._triggers || {};\n              schema[row.tbl_name]._triggers[row.name] = row.sql;\n              break;\n          }\n        }\n      }\n      return schema;\n    });\n  };\n\n\n  /**\n   * Check whether the tables in the current database match up with the ClassFactories.\n   * They will be created or modified as needed.\n   *\n   * @param {Schema} schema\n   * @return {Promise} A promise that resolves with no parameters once all tables are up-to-date.\n   * @private\n   */\n  function syncTables(schema) {\n    console.assert(self.db);\n    return new Promise(function (fulfill, reject) {\n      self.db.transaction(function (tx) {\n        return Promise.all(self.tables.map(function (f) { return syncTable(tx, schema, f); }))\n          .then(fulfill, reject);\n      });\n    });\n  }\n\n\n  /**\n   * Check whether an individual table in the current database matches up with its corresponding Model.\n   * It will be created or modified as needed.\n   *\n   * @param {SQLTransaction} tx - a writeable transaction\n   * @param {Schema} schema\n   * @param {object} f - a {@link Model} or other object that describes a table\n   * @return {Promise} A promise that resolves with no parameters once the table is up-to-date.\n   * @private\n   */\n  function syncTable(tx, schema, f) {\n    // execute CREATE TABLE statement\n    function createTable(name) {\n      var cols = [];\n      for (var col in f.columns) {\n        var attrs = f.columns[col];\n        var decl;\n        console.assert(attrs.type in columnType);\n        switch (attrs.type) {\n          case 'ptr':\n            console.assert(attrs.ref);\n            console.assert(attrs.ref.columns);\n            console.assert(attrs.ref.tableName);\n            console.assert(attrs.ref.key);\n            var foreignType = attrs.ref.columns[attrs.ref.key].type;\n            console.assert(foreignType in columnType);\n            decl = col + ' ' + columnType[foreignType];\n            cols.push(decl);\n            break;\n            \n          case 'list':\n            break;\n\n          default:\n            console.assert(attrs.type in columnType);\n            decl = col + ' ' + columnType[attrs.type];\n            if (f.key === col) {\n              decl += ' PRIMARY KEY';\n            }\n            cols.push(decl);\n        }\n      }\n      return self.exec(tx, 'CREATE ' + (f.temp ? 'TEMP ' : '') + 'TABLE ' + name + ' (' + cols.join(', ') + ')');\n    }\n\n    function dropTable(name) {\n      return self.exec(tx, 'DROP TABLE ' + name);\n    }\n\n    function createIndices(force) {\n      var p = Promise.resolve();\n      var toRemove = (f.tableName in schema) ? clone(schema[f.tableName]._indices) : {};\n      f.indices.forEach(function (index) {\n        var name = 'index_' + f.tableName + '__' + index.join('_');\n        var sql = 'CREATE INDEX ' + name + ' ON ' + f.tableName + ' (' + index.join(', ') + ')';\n        delete toRemove[name];\n        var create = true;\n        var drop = false;\n        if (schema[f.tableName] && schema[f.tableName]._indices && schema[f.tableName]._indices[name]) {\n          if (schema[f.tableName]._indices[name] === sql) {\n            create = false;\n          } else {\n            drop = true;\n          }\n        }\n\n        if (drop) {\n          p = p.then(self.exec(tx, 'DROP INDEX ' + name));\n        }\n        if (create || force) {\n          p = p.then(self.exec(tx, sql));\n        }\n      });\n\n      // delete orphaned indices\n      Object.keys(toRemove).forEach(function (name) {\n        p = p.then(self.exec(tx, 'DROP INDEX ' + name));\n      });\n      return p;\n    }\n\n    // check if table already exists\n    if (f.tableName in schema) {\n      if (f.recreate) {\n        return Promise.resolve()\n          .then(dropTable(f.tableName))\n          .then(createTable(f.tableName))\n          .then(createIndices(true));\n      } else {\n        //console.log(\"table \" + f.tableName + \" exists; checking columns\");\n        var columns = clone(schema[f.tableName]);\n        delete columns._indices;\n        delete columns._triggers;\n        var key;\n\n        var addedColumns = [];\n        var addedForeignKey = false;\n        for (key in f.columns) {\n          if (!(key in columns)) {\n            addedColumns.push(key);\n            if (f.columns[key].ref) {\n              addedForeignKey = true;\n            }\n          }\n        }\n\n        var renamedColumns = clone(f.renamedColumns) || {};\n        for (key in Object.keys(renamedColumns)) {\n          if (!(key in columns)) {\n            delete renamedColumns[key];\n          }\n        }\n\n        var deletedColumns = Object.keys(columns).filter(function (col) {\n          return !(col in f.columns);\n        });\n\n        if (addedForeignKey || Object.keys(renamedColumns).length > 0 || deletedColumns.length > 0) {\n          // must recreate table and migrate data\n          var copyData = function (oldName, newName) {\n            var oldTableColumns = Object.keys(columns).filter(function (col) { return (col in f.columns) || (col in renamedColumns); });\n            var newTableColumns = oldTableColumns.map(function (col) { return (col in renamedColumns) ? renamedColumns[col] : col; });\n            var stmt = \"INSERT INTO \" + newName + \" (\" + newTableColumns.join(\", \") + \") \";\n            stmt += \"SELECT \" + oldTableColumns.join(\", \") + \" FROM \" + oldName + \";\";\n            return self.exec(tx, stmt);\n          };\n\n          var renameTable = function (oldName, newName) {\n            return self.exec(tx, 'ALTER TABLE ' + oldName + ' RENAME TO ' + newName);\n          };\n\n          var newTableName = 'new_' + f.tableName;\n          console.assert(!(newTableName in schema));\n\n          return Promise.resolve()\n            .then(createTable(newTableName))\n            .then(copyData(f.tableName, newTableName))\n            .then(dropTable(f.tableName))\n            .then(renameTable(newTableName, f.tableName))\n            .then(createIndices(true));\n\n        } else if (addedColumns.length > 0) {\n          // alter table, add columns\n          var p = Promise.resolve();\n          addedColumns.map(function (columnName) {\n            var attrs = f.columns[columnName];\n            console.assert(attrs.type in columnType);\n            var columnDecl = columnName + ' ' + columnType[attrs.type];\n            p = p.then(self.exec(tx, 'ALTER TABLE ' + f.tableName + ' ADD COLUMN ' + columnDecl));\n          });\n          return p\n            .then(createIndices());\n        } else {\n          // no table modification is required\n          return createIndices();\n        }\n      }\n    } else {\n      //console.log('creating table: ' + f.tableName);\n      return Promise.resolve()\n        .then(createTable(f.tableName))\n        .then(createIndices(true));\n    }\n  }\n\n\n  /**\n   * Save all objects to database.  Atomic operation- all objects will be saved within the same transaction\n   * or nothing will be written.  Objects can be heterogeneous.\n   *\n   * @param {Instance[]} objects\n   */\n  this.save = function (objects) {\n    objects.map(function (o) {\n      console.assert(('_' + o.model.key) in o, \"object must have a key\");\n    });\n\n    return new Promise(function (resolve, reject) {\n      self.db.transaction(function (tx) {\n        function value(o, col) {\n          var val = o['_' + col];\n          if(typeof val === 'object') {\n            val = JSON.stringify(val);\n          }\n          return val;\n        }\n        \n        function insertLists(o, force) {\n          var changes = o.changes();\n          var f = o.model;\n          var promises = [];\n          Object.keys(f.columns)\n          .filter(function(col) {\n            return (f.columns[col].type === 'list') && (force || changes.indexOf(col) > -1);\n          })\n          .forEach(function(col) {\n            var ref = f.columns[col].ref;\n            var listTable = f.columns[col].listTable;\n            console.assert(ref);\n            console.assert(listTable);\n            var values = o['_' + col];\n            var key = o[f.key];\n            promises.push( self.exec(tx, 'DELETE FROM ' + listTable.tableName + ' WHERE ' + f.key + '=?', [ key ]) );\n            values.forEach(function(value) {\n              promises.push( self.exec(tx, 'INSERT INTO ' + listTable.tableName + ' (' + f.key + ', ' + col + ') VALUES (?, ?)', [key, value]) );\n            });\n          });\n          return Promise.all(promises);\n        }\n        \n        function insert(o, callback) {\n          var f = o.model;\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\n          var cols = Object.keys(f.columns).filter(isNotList);\n          var columns = cols.join(', ');\n          var values = cols.map(function () { return '?'; }).join(', ');\n          var args = cols.map(function(col) { return value(o, col); });\n          return self.exec(tx, 'INSERT OR IGNORE INTO ' + f.tableName + ' (' + columns + ') VALUES (' + values + ')', args, function (tx, results) {\n            var changes = results.rowsAffected !== 0;\n            return callback ? callback(changes) : changes;\n          });\n        }\n\n        function update(o, callback) {\n          var f = o.model;\n          var cols = o.changes();\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\n          var isNotKey = function(col) { return col !== f.key; };\n          var assignments = cols\n            .filter(isNotList)\n            .filter(isNotKey)\n            .map(function (col) { return col + '=?'; })\n            .join(', ');\n          var values = cols\n            .filter(isNotList)\n            .filter(isNotKey)\n            .map(function(col) { return value(o, col); });\n          values.push(o['_' + f.key]); // for WHERE clause\n          return self.exec(tx, 'UPDATE OR IGNORE ' + f.tableName + ' SET ' + assignments + ' WHERE ' + f.key + '=?', values, function (tx, results) {\n            var changes = results.rowsAffected !== 0;\n            return callback ? callback(changes) : changes;\n          });\n        }\n\n        var upsert = function (o) {\n          var p;\n          if (o._isInDb) {\n            p = update(o, function (changed) { return changed ? insertLists(o, false) : insert(o); });\n          } else {\n            p = insert(o, function (changed) { return changed ? insertLists(o, true) : update(o); });\n          }\n          return p\n          .then(function (changed) {\n            console.assert(changed);\n            if(changed) {\n              o._changes = 0;\n              o._isInDb = true;\n            }\n          });\n        };\n\n        return Promise.all(objects.map(upsert)).then(resolve, reject);\n      });\n    });\n  };\n};\n\n\nmodule.exports = Store;\n","'use strict';\n\nfunction startsWith(str, val) {\n  return str.lastIndexOf(val, 0) === 0;\n}\n\n\nfunction clone(obj) {\n  var copy;\n\n  // Handle the 3 simple types, and null or undefined\n  if (null === obj || \"object\" !== typeof obj) {\n    return obj;\n  }\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i]);\n    }\n    return copy;\n  }\n\n  // Handle Object\n  if (obj instanceof Object) {\n    copy = {};\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = clone(obj[attr]);\n      }\n    }\n    return copy;\n  }\n\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\nmodule.exports.startsWith = startsWith;\nmodule.exports.clone = clone;\n"],"sourceRoot":"/source/"}