{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.js","src/model.js","src/query.js","src/set.js","src/store.js","src/util.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"updraft.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar Updraft = {\r\n  Store : require('./store')\r\n};\r\n\r\nmodule.exports = Updraft;\r\n\r\nif (window) {\r\n  window.Updraft = Updraft;\r\n}\r\n","'use strict';\n\nvar Util = require('./util');\nvar Query = require('./query');\n/*jshint -W079 */\nvar Set = require('./set');\n\n\n/**\n * Instances of this type will have properties for all the columns defined in its {@link Model}.\n * You can add additional properties, but they will not be saved.  Object will track which properties have changed\n * since the last save.  Fields of type 'ptr' will return an object { [table's key]:[value], get: [function returning promise evaluating to object] }\n * \n *  Do not create objects of type Instance directly; instead create instances of a Model created by {@link Store#createClass}\n *\n * @see Model\n * @class\n * @example\n *  var store = new Updraft.Store();\n *  var Model = store.createClass(...);\n *  var i = new Model(); // i is an Instance\n */\nfunction Instance(props) {\n  var o = this;\n  o._changes = 0;\n\n  props = props || {};\n  for (var key in props) {\n    o[key] = props[key];\n  }\n}\n\n\n/**\n * Return the object's primary key's value\n *\n * @returns {string} Value of primary key\n * @example\n *  var x = new Class();\n *  x.id = 123;\n *  console.log(x.key());\n *  // -> '123'\n */\nInstance.prototype.key = function() {\n  var key = '_' + this.model.key;\n  console.assert(key in this);\n  return this[key];\n};\n\n\n\n/**\n * Get the fields that have been changed since the object was last loaded/saved\n *\n * @returns {string[]} Names of the fields that have changed\n * @example\n *  var x = new Class();\n *  x.foo = 'bar';\n *  console.log(x.changes());\n *  // -> ['foo']\n */\nInstance.prototype.changes = function () {\n  var changes = [];\n  var propIdx = 0;\n  for (var col in this.model.columns) {\n    var propMask = (1 << propIdx++);\n    if (this._changes & propMask) {\n      changes.push(col);\n    }\n  }\n  return changes;\n};\n\n\n/**\n * Set state to be have no changes\n *\n * @private\n */\nInstance.prototype.clearChanges = function() {\n  this._changes = 0;\n  for (var col in this.model.columns) {\n    if(this.model.columns[col].type === 'set' && this['_' + col]) {\n      this[col].clearChanges();\n    }\n  }\n};\n\n\n/**\n * Add a get/set property to the class\n *\n * @param {Model} model\n * @param proto - function prototype\n * @param {string} col - the column/field to set the property on\n * @param {int} propMask - the bits to set on <tt>_changes</tt>\n * @private\n */\nvar addClassProperty = function(model, proto, col, propMask) {\n  var prop = '_' + col;\n\n  switch(model.columns[col].type) {\n    default:\n      Object.defineProperty(proto, col, {\n        get: function () {\n          return this[prop];\n        },\n        set: function (val) {\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'ptr':\n      Object.defineProperty(proto, col, {\n        get: function () {\n          var ref = this.model.columns[col].ref;\n          console.assert(ref.get);\n          var ret = {};\n          ret.ref = ref;\n          ret.own = this;\n          ret[ref.key] = this[prop];\n          ret.get = function () { return this.ref.get(this.own[prop]); };\n          return ret;\n        },\n        set: function (val) {\n          // allow client to do object.field = otherobject; we'll transform it to object.field = otherobject.key()\n          val = Util.keyOf(val);\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'set':\n      Object.defineProperty(proto, col, {\n        get: function() {\n          if(!(prop in this)) {\n            var o = this;\n            this[prop] = new Set(function() { o._changes |= propMask; });\n          }\n          return this[prop];\n        },\n        set: function(val) {\n          if(!(prop in this)) {\n            var o = this;\n            this[prop] = new Set(function() { o._changes |= propMask; });\n          }\n          this[prop].assign(val);\n          this._changes |= propMask;\n        }\n      });\n      break;\n  }\n};\n\n\n\n/**\n * A class that you can use to create, save, and retrieve {@link Instance}s.\n * Do not create instances of type Model directly; instead use {@link Store#createClass}\n *\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\n * @property {string} key - the name of the primary key for this table\n * @property {columnType} keyType - the type of the primary key for this table\n * @property {Object} columns - an object describing the fields of objects of this type\n * @property {string} columns.key - name of the field\n * @property {object} columns.value\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\n * @property {bool} [columns.value.index=false] - create an index on this field\n * @property {Query} all - use to construct a query\n * @see ExampleModel\n * @class\n * @param {Store} store\n * @param {ClassTemplate} templ\n * @example\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *  \n *  var x = new ExampleModel({keyField: 123});\n */\nfunction Model(store, templ) {\n  console.assert(store);\n  console.assert(templ);\n  console.assert(templ.tableName);\n  console.assert(templ.tableName[0] !== '_');\n  console.assert(templ.columns);\n  console.assert(Object.keys(templ.columns).length < 64);\n  console.assert(!('changes' in templ.columns));\n  console.assert(!('template' in templ.columns));\n  console.assert(!templ.renamedColumns || Object.keys(templ.renamedColumns).every(function (old) { return !(old in templ.columns); }));\n  \n  var ModelInstance = function() {\n    Instance.apply(this, arguments);\n  };\n\n  ModelInstance.prototype = Object.create(Instance.prototype);\n  ModelInstance.prototype.constructor = ModelInstance;\n  \n  var m = function(props) {\n    return new ModelInstance(props);\n  };\n\n  Object.setPrototypeOf(m, Model.prototype);\n  \n  Object.defineProperty(ModelInstance.prototype, 'model', { enumerable: true, value: m });\n  Object.defineProperty(ModelInstance.prototype, 'factory', { enumerable: true, value: m });\n\n  m.ModelInstance = ModelInstance;\n  \n  Object.defineProperty(m, 'store', { enumerable: true, value: store });\n  \n  Object.defineProperty(m, 'all', {\n    get: function() {\n      return new Query(this, this.store);\n    }\n  });\n\n  m.indices = [];\n\n  for (var key in templ) {\n    m[key] = Util.clone(templ[key]);\n  }\n\n  m.key = null;\n  m.keyType = null;\n\n  var propIdx = 0;\n  for(var col in m.columns) {\n    if (m.columns[col].key) {\n      m.key = col;\n      m.keyType = m.columns[col].type;\n    }\n    if (m.columns[col].index) {\n      m.indices.push([col]);\n    }\n\n    var propMask = (1 << propIdx++);\n    addClassProperty(m, ModelInstance.prototype, col, propMask);\n    if (propIdx >= 63) {\n      throw new Error(\"class has too many columns- max 63\");\n    }\n  }\n\n  console.assert(m.key);\n\n  return m;\n}\n\n\n/**\n * Get a single object from database by its key\n *\n * @param id - value to find in table's primary key\n * @returns {Promise<Instance>} Promise that resolves with element or null if not found\n * @example\n *  Class.get(123).then(function(obj) {\n *    if(obj) {\n *      console.log('found object 123:', obj);\n *    } else {\n *      console.log('object 123 was not in db');\n *    }\n *  });\n */\nModel.prototype.get = function (id) {\n  return this.all.where(this.key, '=', id).get()\n  .then(function(results) {\n    console.assert(results.length < 2);\n    if(results.length === 0) {\n      return null;\n    } else {\n      return results[0];\n    }\n  });\n};\n\n\n/**\n * construct object from a database result row\n *\n * @param {SQLRow} row\n * @return instance of Model with fields initialized according to row, with _isInDb=true and no changes set\n * @private\n */\nModel.prototype.constructFromDb = function(row) {\n  var o = new this.ModelInstance();\n  for(var col in row) {\n    var val = row[col];\n    var _col = '_' + col;\n    switch(this.columns[col].type) {\n      case 'json':\n        o[_col] = JSON.parse(val);\n        break;\n      case 'set':\n        o[_col].push(val);\n        break;\n      default:\n        o[_col] = val;\n        break;\n    }\n  }\n\n  o._isInDb = true;\n  console.assert(o._changes === 0);\n  return o;\n};\n\n\n\n/**\n * Example class, an {@link Instance} returned by {@link Store#createClass}\n *\n * @class\n * @extends Instance\n * @name ExampleModel\n * @property {int} keyField - object's primary key, unique in the table\n * @property {string} stringField\n * @property {object} jsonField - can be any javascript type, object, or nesting of objects.  Will be \n *           stored stringified, so any shared properties will no longer be shared after reloading from db.\n * @property {int} indexedField - a regular integer field, but queries testing indexed fields will be faster.\n *           Doesn't have to be <tt>int</tt>- any field type can be indexed.\n * @property childField - a pseudo 'ChildClass' object.  Although you can assign to it, the object won't be available.\n *           That is, you will always need to call 'childField.get()' and wait for the promise, even if you just\n *           assigned to it.\n * @property {int} childField.id - the key of the child object pointed to.  Note that the member 'id' is because \n *           ChildClass's key is named 'id'; similarly the type is inherited from ChildClass's key type.  This \n *           is the only part of the reference that is stored on the object.\n * @property {Set} setField - a searchable collection of objects\n * @see ClassTemplate, Model\n * @example\n *  var ChildClass = store.createClass({\n *    tableName: 'childClass',\n *    columns: {\n *      id: { type: 'int', key: true },\n *      intField: { type: 'int', index: true }\n *    }\n *  });\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *\n *  var child = new ChildClass({id: 321, intField: 456});\n *\n *  var x = new ExampleModel();\n *  x.keyField = 123;\n *  x.stringField = 'string example';\n *  x.jsonField = { x: 1, y: 'a', z: { foo: 'bar' } };\n *  console.log(x.changes());\n *  // -> ['keyField', 'stringField', 'jsonField']\n *\n *  // the following lines are exactly equivalent:\n *  x.childField = child;\n *  x.childField = child.id;\n *  x.childField = 321;\n *\n *  console.log(x.childField.id); // -> 321\n *\n *  x.childField.get().then(function(c) {\n *    // child was never saved, so c is null, unless there was\n *    // already a ChildClass with id=321 in the db');\n *  });\n *\n *  // ... assume more objects have been created and saved ...\n *\n *  ExampleModel.all.where('childField.intField', '=', 456).get()\n *  .then(function(results) {\n *    // results is an array containing (a copy of) x and anything\n *    // else that has the same \n *  });\n */\n\n\nmodule.exports = Model;\n","'use strict';\n\nvar Util = require('./util');\nvar keyOf = Util.keyOf;\n\n\n/**\n * Do not construct objects of type Query directly- instead, use {@link Model}.all\n * @class\n * @constructor\n * @param {Model} model\n * @param {Store} store\n */\nvar Query = function(model, store) {\n  console.assert(model);\n  console.assert(store);\n  this._model = model;\n  this._store = store;\n  this._justCount = false;\n  this._tables = [model.tableName];\n  this._columns = [];\n  this._conditions = [];\n  this._order = undefined;\n  this._limit = undefined;\n  this._offset = undefined;\n  this._asc = true;\n  this._nocase = false;\n\n  // add child tables\n  for(var col in model.columns) {\n    if(model.columns[col].type !== 'set') {\n      this._columns.push(model.tableName + '.' + col);\n    }\n  }\n};\n\n\nQuery.prototype.all = function() {\n  return this.get();\n};\n\n\nQuery.prototype.addCondition = function(conj, col, op, val) {\n  var fields = col.split(/\\./);\n  var field;\n  var f = this._model;\n  val = keyOf(val);\n\n  for(var i=0; i<fields.length - 1; i++) {\n    field = fields[i];\n    console.assert(field in f.columns);\n    var ref = f.columns[field].ref;\n    console.assert(ref);\n    if(this._tables.indexOf(ref.tableName) === -1) {\n      this._tables.push(ref.tableName);\n      this._conditions.push({\n        conj: 'AND',\n        col: f.tableName + '.' + field,\n        op: '=',\n        val: ref.tableName + '.' + ref.key\n      });\n    }\n    f = ref;\n  }\n  \n  field = fields[fields.length - 1];\n\n  switch(op) {\n    case 'contains':\n      console.assert(f.columns[field].type === 'set');\n      var setTable = f.columns[field].setTable;\n      console.assert(setTable);\n\n      if(this._tables.indexOf(setTable.tableName) === -1) {\n        this._tables.push(setTable.tableName);\n        this._conditions.push({\n          conj: 'AND',\n          col: f.tableName + '.' + f.key,\n          op: '=',\n          val: setTable.tableName + '.' + f.key\n        });\n      }\n\n      this._conditions.push({\n        conj: conj,\n        col: setTable.tableName + '.' + field,\n        op: '=',\n        val: '?',\n        arg: val\n      });\n      break;\n\n    default:\n      console.assert(f.columns[field].type !== 'set');\n      this._conditions.push({\n        conj: conj,\n        col: f.tableName + '.' + field,\n        op: op,\n        val: '?',\n        arg: val\n      });\n    break;\n  }\n  return this;\n};\n\n\n/**\n * Adds an 'AND' condition to the query\n *\n * @method\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#or\n * @example\n *  return Class.all.where('col2', '>', 10).and('col2', '<', 30).get();\n *  // -> SELECT ... WHERE col2 > 10 AND col2 < 30\n */\nQuery.prototype.and = function(col, op, val) {\n  return this.addCondition('AND', col, op, val);\n};\n\n\n/**\n * alias for {@link Query#and}\n *\n * @method\n * @return {Query}\n * @example\n *  return Class.all.where('col2', '>', 10).get();\n */\nQuery.prototype.where = Query.prototype.and;\n\n\n/**\n * Adds an 'OR' condition to the query\n *\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#and\n * @example\n *  return Class.all.where('col2', '=', 10).and('col2', '=', 30).get();\n *  // -> SELECT ... WHERE col2 = 10 OR col2 = 30\n */\nQuery.prototype.or = function(col, op, val) {\n  return this.addCondition('OR', col, op, val);\n};\n\n\n/**\n * Sort the results by specified field\n *\n * @param {string} col - column to sort by\n * @param {bool} [asc=true] - sort ascending (true, default) or descending (false)\n * @return {Query}\n * @see Query#nocase\n * @example\n *  return Class.all.order('x').get();\n *  // -> SELECT ... ORDER BY x\n */\nQuery.prototype.order = function(col, asc) {\n  this._order = this._model.tableName + '.' + col;\n  if(typeof asc !== 'undefined') {\n    this._asc = asc;\n  }\n  return this;\n};\n\n/**\n * Changes the match collation to be case-insensitive.  Only applies to result sorting, as 'LIKE' is \n * always case-insensitive\n *\n * @return {Query}\n * @see Query#order\n * @example\n *  return Class.all.order('x').nocase().get();\n *  // -> SELECT ... ORDER BY x COLLATE NOCASE\n */\nQuery.prototype.nocase = function() {\n  this._nocase = true;\n  return this;\n};\n\n\n/**\n * Limits the result set to a certain number.  Useful in pagination\n *\n * @return {Query}\n * @see Query#offset\n * @example\n *  return Class.all.limit(5).get();\n *  // -> SELECT ... FROM ... LIMIT 5\n */\nQuery.prototype.limit = function(count) {\n  this._limit = count;\n  return this;\n};\n\n\n/**\n * Skip a number of results.  Useful in pagination\n *\n * @return {Query}\n * @see Query#limit\n * @example\n *  return Class.all.limit(10).offset(50).get();\n *  // -> SELECT ... FROM ... LIMIT 10 OFFSET 50\n */\nQuery.prototype.offset = function(count) {\n  this._offset = count;\n  return this;\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the count of objects that match\n *\n * @return {Promise<int>}\n * @see Query#get\n * @example\n *  return Class.all.count()\n *  .then(function(count) { console.log(count + \" objects\") });\n *  // -> SELECT COUNT(*) FROM ...\n */\nQuery.prototype.count = function() {\n  this._justCount = true;\n  return this.get();\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the array of objects that match any conditions\n * set on the Query\n *\n * @return {Promise<Instance[]>}\n * @see Query#count\n * @example\n *  return Class.all.where('x', '>', 0).get();\n *  // -> SELECT ... WHERE x > 0\n */\nQuery.prototype.get = function() {\n  var countProp = 'COUNT(*)';\n  var stmt = 'SELECT ';\n  var model = this._model;\n  if(this._justCount) {\n    stmt += countProp;\n  } else {\n    stmt += this._columns.join(', ');\n  }\n  stmt += ' FROM ' + this._tables.join(', ');\n  var args = [];\n  for(var i=0; i<this._conditions.length; i++) {\n    var cond = this._conditions[i];\n    stmt += (i === 0) ? ' WHERE ' : (' ' + cond.conj + ' ');\n    stmt += cond.col + ' ' + cond.op + ' ' + cond.val;\n    if('arg' in cond) {\n      args.push(cond.arg);\n    }\n  }\n  if(this._order) {\n    stmt += ' ORDER BY ' + this._order;\n    stmt += (this._nocase ? ' COLLATE NOCASE' : '');\n    stmt += (this._asc ? ' ASC' : ' DESC');\n  }\n  console.assert(!this._offset || this._limit);\n  if(this._limit) {\n    stmt += ' LIMIT ' + this._limit;\n    if(this._offset) {\n      stmt += ' OFFSET ' + this._offset;\n    }\n  }\n\n  var objects = [];\n  var query = this;\n  return this._store.execRead(stmt, args, function (tx, results) {\n    if(query._justCount) {\n      return results.rows.item(0)[countProp];\n    }\n    for (var i = 0; i < results.rows.length; i++) {\n      var o = model.constructFromDb(results.rows.item(i));\n      objects.push(o);\n    }\n    return Promise.all(objects.map(function(o) {\n      return Promise.all(\n        Object.keys(model.columns)\n        .filter(function(col) {\n          return (model.columns[col].type === 'set');\n        })\n        .map(function(col) {\n          var setTable = model.columns[col].setTable;\n          console.assert(setTable);\n          var key = o.key();\n          var s = 'SELECT ' + col;\n          s += ' FROM ' + setTable.tableName;\n          s += ' WHERE ' + query._model.key + ' = ?';\n          return query._store.exec(tx, s, [key], function(tx, results) {\n            if(results.rows.length > 0) {\n              o[col].initFromDb(results);\n            }\n          });\n        })\n      );\n    }))\n    .then(function() {\n      return objects;\n    });\n  });\n};\n\n\nmodule.exports = Query;\n","'use strict';\n\nvar Util = require('./util');\n\n/**\n * State that a value can be in\n * @private\n * @enum\n */\nvar State = {\n  saved:    1 << 1,\n  added:    1 << 2,\n  removed:  1 << 3\n};\n\n\n/**\n * @class\n * @param {function} dirtyFcn - function to call when set's state changes\n */\nfunction Set(dirtyFcn) {\n  this.dirtyFcn = dirtyFcn;\n  this._values = {};\n}\n\n\n/**\n * load values from a database; initialize values\n * @private\n * @param {SQLResultSet} results - database row\n */\nSet.prototype.initFromDb = function(results) {\n  for(var i=0; i<results.rows.length; i++) {\n    var row = results.rows.item(i);\n    console.assert(Object.keys(row).length === 1);\n    var item = row[Object.keys(row)[0]];\n    this._values[item] = State.saved;\n  }\n};\n\n\n/**\n * Set all values from an array.  <tt>Add</tt>s all values, and <tt>remove</tt>s any existing set values that are\n * not in <tt>arr</tt>\n * @param {Array} arr - array of values to assign.  If values are {@link Instance}s, assign their <tt>key()</tt>s instead\n */\nSet.prototype.assign = function(arr) {\n  this.clear();\n  this.add.apply(this, arr);\n};\n\n\n/**\n * Removes all objects from set\n */\nSet.prototype.clear = function() {\n  for(var val in this._values) {\n    this._values[val] = State.removed;\n  }\n};\n\n\n/**\n * Adds value(s) to set\n * @param {object[]} arguments - values to add\n */\nSet.prototype.add = function() {\n  var dirty = false;\n  var self = this;\n  Array.prototype.slice.call(arguments)\n  .map(Util.keyOf)\n  .forEach(function(arg) {\n    console.assert(typeof(arg) !== 'object');\n    if(self._values[arg] !== State.saved) {\n      self._values[arg] = State.added;\n      dirty = true;\n    }\n  });\n  if(dirty) {\n    this.dirtyFcn();\n  }\n};\n\n\n/**\n * Alias for {@link Set#add}\n * @param {object[]} arguments - values to add\n */\nSet.prototype.push = function() {\n  return this.add.apply(this, arguments);\n};\n\n\n/**\n * Removes value(s) from set\n * @param {object[]} arguments - values to remove\n */\nSet.prototype.remove = function() {\n  var dirty = false;\n  var self = this;\n  Array.prototype.slice.call(arguments)\n  .map(Util.keyOf)\n  .forEach(function(arg) {\n    self._values[arg] = State.removed;\n    dirty = true;\n  });\n  if(dirty) {\n    this.dirtyFcn();\n  }\n};\n\n\n/**\n * Gets values from set which match the given <tt>stateMask</tt>\n * @param {int} stateMask - states of objects to return\n * @return {Array} - values that match <tt>stateMask</tt>\n * @private\n */\nSet.prototype.which = function(stateMask) {\n  var self = this;\n  return Object.keys(this._values)\n  .filter(function(val) {\n    return (self._values[val] & stateMask);\n  });\n};\n\n\n/**\n * Gets valid (added or saved) values of the set\n * @return {Array}\n */\nSet.prototype.values = function() {\n  return this.which(State.saved | State.added);\n};\n\n\n/**\n * Gets the values that have been added to the set since it was last saved\n * @return {Array}\n */\nSet.prototype.getAdded = function() {\n  return this.which(State.added);\n};\n\n\n/**\n * Gets the values that have been removed from the set since it was last saved\n * @return {Array}\n */\nSet.prototype.getRemoved = function() {\n  return this.which(State.removed);\n};\n\n\n/**\n * Marks the values in the set as saved.  Any objects marked 'remove' will be\n * expunged from the set.\n */\nSet.prototype.clearChanges = function() {\n  var newValues = {};\n  for(var val in this._values) {\n    if(this._values[val] !== State.removed) {\n      newValues[val] = State.saved;\n    }\n  }\n  this._values = newValues;\n};\n\n\nmodule.exports = Set;\n","'use strict';\n\nvar util = require('./util');\nvar Model = require('./model');\nvar clone = util.clone;\nvar startsWith = util.startsWith;\n\n\n/**\n * Column types.  Ignore the values; only use the keys.  Note that these are just column\n * affinities, and technically any value type can be stored in any column type.\n * see {@link https://www.sqlite.org/datatype3.html}\n *\n * @enum {string}\n * @readonly\n */\nvar columnType = {\n  'int': 'INTEGER',\n  'bool': 'BOOL',\n  'real': 'REAL',\n  'text': 'TEXT',\n  'blob': 'BLOB',\n  'date': 'DATE',\n  'datetime': 'DATETIME',\n  \n  /** object will be serialized & restored as JSON text */\n  'json': 'TEXT',\n\n  /** points to an object in another table.  Set 'ref' to another {@link Model}.  Its affinity will be that table's key's affinity */\n  'ptr': 'ref',\n\n  /** unordered collection.  Set 'ref' to be either a {@link Model} or another {@link columnType} */\n  'set': '',\n};\n\n\n/**\n * The class template used by {@link Store#createClass}.\n *\n * @typedef\n * @name ClassTemplate\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\n * @property {bool} [recreate=false] - whether the table should be recreated (dropped) if it exists.  All data will be lost.\n * @property {bool} [temp=false] - whether the table should be created as temporary (will not persist)\n * @property {Object} columns - an object describing the fields of objects of this type\n * @property {string} columns.key - name of the field\n * @property {object} columns.value\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\n * @property {bool} [columns.value.index=false] - create an index on this field\n * @property {object} [renamedColumns] - old column name is the key, new column name is the value\n * @example\n *  {\n *    tableName: 'users',\n *    columns: {\n *      'id': { key: true, type: 'int' },\n *      'name': { type: 'text' },\n *      'address3': { type: 'text' }\n *    },\n *    renamedColumns: {\n *      // migrate 'address2' column data into column 'address3'\n *      // the column must be specified in 'columns'\n *      'address2': 'address3'\n *    }\n *  }\n */\n\n\n/**\n * The parameters used to open a database\n *\n * @typedef\n * @name StoreOptions\n * @property {string} name - the name of the database to open\n */\n\n\n/**\n * Interface for creating classes & database interaction\n *\n * @class\n * @property {bool} [logSql=false] - log sql statements to console.log\n */\nvar Store = function () {\n  var self = this;\n  this.tables = [];\n  this.triggers = {};\n  this.logSql = false;\n\n  this.columnType = columnType;\n  \n  /**\n   * create a new type whose instances can be stored in a database\n   * @param {ClassTemplate} templ\n   * @return {Model}\n   * @see ExampleModel\n   * @example \n   *  var ExampleModel = store.createClass({\n   *    tableName: 'exampleModel',\n   *    columns: {\n   *      keyField: { type: 'int', key: true },\n   *      stringField: { type: 'text' },\n   *      jsonField: { type: 'json' },\n   *      indexedField: { type: 'int', index: true },\n   *      childField: { type: 'ptr', ref: ChildClass }\n   *    }\n   *  });\n   */\n  this.createClass = function(templ) {\n    var m = new Model(self, templ);\n    self.tables.push(m);\n    return m;\n  };\n  \n\n  /**\n   * Delete all tables in database.  For development purposes; you probably don't want to ship with this.\n   *\n   * @global\n   * @typedef\n   * @param {StoreOptions} opts\n   * @return {Promise} a promise that resolves when all tables are deleted\n   * @see Store#open\n   * @example\n   *    store.purge({name: 'my cool db'}).then(function() {\n   *      // everything is gone\n   *    });\n   */\n  this.purge = function(opts) {\n    console.assert(!self.db);\n\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\n    console.assert(self.db);\n    return self.readSchema()\n      .then(function(schema) {\n        return new Promise(function(fulfill, reject) {\n          self.db.transaction(function(tx) {\n            var p = Promise.resolve();\n            Object.keys(schema).forEach(function(table) {\n              p = p.then(self.exec(tx, 'DROP TABLE ' + table));\n            });\n            return p.then(function() {\n              self.db = null;\n            })\n            .then(fulfill, reject);\n          });\n        });\n      });\n  };\n\n\n  /**\n   * open the database\n   *\n   * @param {StoreOptions} opts\n   * @return {Promise} a promise that resolves with no parameters when the database is created and ready\n   * @example\n   *    store.open({name: 'my cool db'}).then(function() {\n   *      // start loading & saving objects\n   *    });\n   */\n  this.open = function (opts) {\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\n    console.assert(self.db);\n    \n    // add set tables\n    var setTables = [];\n    for(var i=0; i<self.tables.length; i++) {\n      var table = self.tables[i];\n      for(var col in table.columns) {\n        if(table.columns[col].type === 'set') {\n          var ref = table.columns[col].ref;\n          var type = (ref.keyType ? ref.keyType : type);\n          console.assert(ref);\n          var setTable = {};\n          setTable.tableName = table.tableName + '_' + col;\n          setTable.recreate = table.recreate;\n          setTable.temp = table.temp;\n          setTable.key = '';\n          setTable.keyType = table.keyType;\n          setTable.columns = {};\n          setTable.columns[table.key] = { type: table.keyType }; // note: NOT setting key=true, as it would impose unique constraint\n          setTable.columns[col] = { type: type };\n          setTable.indices = [ [table.key], [col] ];\n          table.columns[col].setTable = setTable;\n          setTables.push(setTable);\n        }\n      }\n    }\n    \n    self.tables = self.tables.concat(setTables);\n    \n    return self.readSchema()\n            .then(syncTables);\n  };\n\n\n  /**\n   * close the database\n   */\n  this.close = function () {\n    self.db = null;\n    self.tables = [];\n    self.triggers = {};\n  };\n\n\n  /**\n   * exec a sql statement within a given transaction\n   *\n   * @param {SQLTransaction} tx - a transaction created by <tt>db.transaction</tt> or <tt>db.readTransaction</tt>\n   * @param {string} stmt - sql statement to execute\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\n   * @private\n   */\n  this.exec = function(tx, stmt, args, callback) {\n    if(self.logSql) {\n      console.log(stmt, args);\n    }\n    return new Promise(function (fulfill, reject) {\n      try {\n        tx.executeSql(stmt, args,\n                      function (tx, results) {\n                        var ret = callback ? callback(tx, results) : null;\n                        return Promise.resolve(ret).then(fulfill, reject);\n                      },\n                      function (tx, error) {\n                        reportError(error);\n                        reject(error);\n                      });\n      } catch (reason) {\n        console.log('Failed to exec \"' + stmt + '\":' + reason);\n        throw reason;\n      }\n    });\n  };\n\n\n  /**\n   * exec a sql statement within a new read transaction\n   *\n   * @param {string} stmt - sql statement to execute\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\n   * @private\n   */\n  this.execRead = function(stmt, args, callback) {\n    console.assert(self.db);\n    return new Promise(function (fulfill, reject) {\n      self.db.readTransaction(function (rtx) {\n        return self.exec(rtx, stmt, args, callback)\n                .then(fulfill, reject);\n      });\n    });\n  };\n\n\n  function reportError(error) {\n    switch (error.code) {\n      case error.SYNTAX_ERR:\n        console.log(\"Syntax error: \" + error.message);\n        break;\n      default:\n        console.log(error);\n    }\n  }\n\n\n  /**\n   * Database schema.  The outer keys will be the tables in the database.  The values will consist of an\n   * object whose keys will be the table's rows and values will be the row's type.  It will also have an\n   * '_indices' object with all the indices found.\n   * Note: tables or indices beginning with underscore or 'sqlite' will be ignored\n   *\n   * @typedef\n   * @name Schema\n   * @example\n   *    var schema = {\n   *      'todos': {\n   *        _indices: {\n   *          'index_todos__name': 'CREATE INDEX ...',\n   *        },\n   *        _triggers: {\n   *          'trigger_todos__task': 'CREATE TRIGGER ...',\n   *        },\n   *        'id': 'INTEGER PRIMARY KEY',\n   *        'name': 'TEXT',\n   *      },\n   *      'tasks': {\n   *        'id': 'INTEGER PRIMARY KEY',\n   *        'description': 'TEXT',\n   *      }\n   *    };\n   */\n\n\n  /**\n   * get the existing database's schema in object form\n   *\n   * @return {Promise} a promise that resolves with the {@link Schema}\n   */\n  this.readSchema = function () {\n    function tableFromSql(sql) {\n      var table = { _indices: {}, _triggers: {} };\n      var matches = sql.match(/\\((.*)\\)/);\n      if (matches) {\n        var fields = matches[1].split(',');\n        for (var i = 0; i < fields.length; i++) {\n          var ignore = /^\\s*(primary|foreign)\\s+key/i;  // ignore standalone 'PRIMARY KEY xxx'\n          if (fields[i].match(ignore)) {\n            continue;\n          }\n          var quotedName = /\"(.+)\"\\s+(.*)/;\n          var unquotedName = /(\\w+)\\s+(.*)/;\n          var parts = fields[i].match(quotedName);\n          if (!parts) {\n            parts = fields[i].match(unquotedName);\n          }\n          if (parts) {\n            table[parts[1]] = parts[2];\n          }\n        }\n      }\n      return table;\n    }\n\n    return self.execRead('SELECT name, tbl_name, type, sql FROM sqlite_master', [], function (tx, results) {\n      /*jshint camelcase:false*/\n      var schema = {};\n      for (var i = 0; i < results.rows.length; i++) {\n        var row = results.rows.item(i);\n        if (row.name[0] != '_' && !startsWith(row.name, 'sqlite')) {\n          switch (row.type) {\n            case 'table':\n              schema[row.name] = tableFromSql(row.sql);\n              break;\n            case 'index':\n              schema[row.tbl_name]._indices = schema[row.tbl_name]._indices || {};\n              schema[row.tbl_name]._indices[row.name] = row.sql;\n              break;\n            case 'trigger':\n              schema[row.tbl_name]._triggers = schema[row.tbl_name]._triggers || {};\n              schema[row.tbl_name]._triggers[row.name] = row.sql;\n              break;\n          }\n        }\n      }\n      return schema;\n    });\n  };\n\n\n  /**\n   * Check whether the tables in the current database match up with the ClassFactories.\n   * They will be created or modified as needed.\n   *\n   * @param {Schema} schema\n   * @return {Promise} A promise that resolves with no parameters once all tables are up-to-date.\n   * @private\n   */\n  function syncTables(schema) {\n    console.assert(self.db);\n    return new Promise(function (fulfill, reject) {\n      self.db.transaction(function (tx) {\n        return Promise.all(self.tables.map(function (f) { return syncTable(tx, schema, f); }))\n          .then(fulfill, reject);\n      });\n    });\n  }\n\n\n  /**\n   * Check whether an individual table in the current database matches up with its corresponding Model.\n   * It will be created or modified as needed.\n   *\n   * @param {SQLTransaction} tx - a writeable transaction\n   * @param {Schema} schema\n   * @param {object} f - a {@link Model} or other object that describes a table\n   * @return {Promise} A promise that resolves with no parameters once the table is up-to-date.\n   * @private\n   */\n  function syncTable(tx, schema, f) {\n    // execute CREATE TABLE statement\n    function createTable(name) {\n      var cols = [];\n      for (var col in f.columns) {\n        var attrs = f.columns[col];\n        var decl;\n        console.assert(attrs.type in columnType);\n        switch (attrs.type) {\n          case 'ptr':\n            console.assert(attrs.ref);\n            console.assert(attrs.ref.columns);\n            console.assert(attrs.ref.tableName);\n            console.assert(attrs.ref.key);\n            var foreignType = attrs.ref.columns[attrs.ref.key].type;\n            console.assert(foreignType in columnType);\n            decl = col + ' ' + columnType[foreignType];\n            cols.push(decl);\n            break;\n            \n          case 'set':\n            break;\n\n          default:\n            console.assert(attrs.type in columnType);\n            decl = col + ' ' + columnType[attrs.type];\n            if (f.key === col) {\n              decl += ' PRIMARY KEY';\n            }\n            cols.push(decl);\n        }\n      }\n      return self.exec(tx, 'CREATE ' + (f.temp ? 'TEMP ' : '') + 'TABLE ' + name + ' (' + cols.join(', ') + ')');\n    }\n\n    function dropTable(name) {\n      return self.exec(tx, 'DROP TABLE ' + name);\n    }\n\n    function createIndices(force) {\n      var p = Promise.resolve();\n      var toRemove = (f.tableName in schema) ? clone(schema[f.tableName]._indices) : {};\n      f.indices.forEach(function (index) {\n        var name = 'index_' + f.tableName + '__' + index.join('_');\n        var sql = 'CREATE INDEX ' + name + ' ON ' + f.tableName + ' (' + index.join(', ') + ')';\n        delete toRemove[name];\n        var create = true;\n        var drop = false;\n        if (schema[f.tableName] && schema[f.tableName]._indices && schema[f.tableName]._indices[name]) {\n          if (schema[f.tableName]._indices[name] === sql) {\n            create = false;\n          } else {\n            drop = true;\n          }\n        }\n\n        if (drop) {\n          p = p.then(self.exec(tx, 'DROP INDEX ' + name));\n        }\n        if (create || force) {\n          p = p.then(self.exec(tx, sql));\n        }\n      });\n\n      // delete orphaned indices\n      Object.keys(toRemove).forEach(function (name) {\n        p = p.then(self.exec(tx, 'DROP INDEX ' + name));\n      });\n      return p;\n    }\n\n    // check if table already exists\n    if (f.tableName in schema) {\n      if (f.recreate) {\n        return Promise.resolve()\n          .then(dropTable(f.tableName))\n          .then(createTable(f.tableName))\n          .then(createIndices(true));\n      } else {\n        //console.log(\"table \" + f.tableName + \" exists; checking columns\");\n        var columns = clone(schema[f.tableName]);\n        delete columns._indices;\n        delete columns._triggers;\n        var key;\n\n        var addedColumns = [];\n        var addedForeignKey = false;\n        for (key in f.columns) {\n          if (!(key in columns)) {\n            addedColumns.push(key);\n            if (f.columns[key].ref) {\n              addedForeignKey = true;\n            }\n          }\n        }\n\n        var renamedColumns = clone(f.renamedColumns) || {};\n        for (key in Object.keys(renamedColumns)) {\n          if (!(key in columns)) {\n            delete renamedColumns[key];\n          }\n        }\n\n        var deletedColumns = Object.keys(columns).filter(function (col) {\n          return !(col in f.columns);\n        });\n\n        if (addedForeignKey || Object.keys(renamedColumns).length > 0 || deletedColumns.length > 0) {\n          // must recreate table and migrate data\n          var copyData = function (oldName, newName) {\n            var oldTableColumns = Object.keys(columns).filter(function (col) { return (col in f.columns) || (col in renamedColumns); });\n            var newTableColumns = oldTableColumns.map(function (col) { return (col in renamedColumns) ? renamedColumns[col] : col; });\n            var stmt = \"INSERT INTO \" + newName + \" (\" + newTableColumns.join(\", \") + \") \";\n            stmt += \"SELECT \" + oldTableColumns.join(\", \") + \" FROM \" + oldName + \";\";\n            return self.exec(tx, stmt);\n          };\n\n          var renameTable = function (oldName, newName) {\n            return self.exec(tx, 'ALTER TABLE ' + oldName + ' RENAME TO ' + newName);\n          };\n\n          var newTableName = 'new_' + f.tableName;\n          console.assert(!(newTableName in schema));\n\n          return Promise.resolve()\n            .then(createTable(newTableName))\n            .then(copyData(f.tableName, newTableName))\n            .then(dropTable(f.tableName))\n            .then(renameTable(newTableName, f.tableName))\n            .then(createIndices(true));\n\n        } else if (addedColumns.length > 0) {\n          // alter table, add columns\n          var p = Promise.resolve();\n          addedColumns.map(function (columnName) {\n            var attrs = f.columns[columnName];\n            console.assert(attrs.type in columnType);\n            var columnDecl = columnName + ' ' + columnType[attrs.type];\n            p = p.then(self.exec(tx, 'ALTER TABLE ' + f.tableName + ' ADD COLUMN ' + columnDecl));\n          });\n          return p\n            .then(createIndices());\n        } else {\n          // no table modification is required\n          return createIndices();\n        }\n      }\n    } else {\n      //console.log('creating table: ' + f.tableName);\n      return Promise.resolve()\n        .then(createTable(f.tableName))\n        .then(createIndices(true));\n    }\n  }\n\n\n  /**\n   * Save all objects to database.  Atomic operation- all objects will be saved within the same transaction\n   * or nothing will be written.  Objects can be heterogeneous.\n   *\n   * @param {Instance[]} objects\n   */\n  this.save = function (objects) {\n    objects.map(function (o) {\n      console.assert(('_' + o.model.key) in o, \"object must have a key\");\n    });\n\n    return new Promise(function (resolve, reject) {\n      self.db.transaction(function (tx) {\n        function value(o, col) {\n          var val = o['_' + col];\n          if(typeof val === 'object') {\n            val = JSON.stringify(val);\n          }\n          return val;\n        }\n        \n        function insertSets(o, force) {\n          var changes = o.changes();\n          var f = o.model;\n          var promises = [];\n          Object.keys(f.columns)\n          .filter(function(col) {\n            return (f.columns[col].type === 'set') && (force || changes.indexOf(col) > -1);\n          })\n          .forEach(function(col) {\n            var ref = f.columns[col].ref;\n            var setTable = f.columns[col].setTable;\n            console.assert(ref);\n            console.assert(setTable);\n            var set = o['_' + col];\n            if(set) {\n              var key = o.key();\n              var deletions = set.getRemoved();\n              var additions = set.getAdded();\n              deletions.forEach(function(del) {\n                promises.push( self.exec(tx, 'DELETE FROM ' + setTable.tableName + ' WHERE ' + f.key + '=? AND ' + col + '=?', [ key, del ]) );\n              });\n              additions.forEach(function(add) {\n                promises.push( self.exec(tx, 'INSERT INTO ' + setTable.tableName + ' (' + f.key + ', ' + col + ') VALUES (?, ?)', [key, add]) );\n              });\n            }\n          });\n          return Promise.all(promises);\n        }\n        \n        function insert(o, callback) {\n          var f = o.model;\n          var isNotSet = function(col) { return f.columns[col].type !== 'set'; };\n          var cols = Object.keys(f.columns).filter(isNotSet);\n          var columns = cols.join(', ');\n          var values = cols.map(function () { return '?'; }).join(', ');\n          var args = cols.map(function(col) { return value(o, col); });\n          return self.exec(tx, 'INSERT OR IGNORE INTO ' + f.tableName + ' (' + columns + ') VALUES (' + values + ')', args, function (tx, results) {\n            var changes = results.rowsAffected !== 0;\n            return callback ? callback(changes) : changes;\n          });\n        }\n\n        function update(o, callback) {\n          var f = o.model;\n          var cols = o.changes();\n          var isNotSet = function(col) { return f.columns[col].type !== 'set'; };\n          var isNotKey = function(col) { return col !== f.key; };\n          var assignments = cols\n            .filter(isNotSet)\n            .filter(isNotKey)\n            .map(function (col) { return col + '=?'; })\n            .join(', ');\n          var values = cols\n            .filter(isNotSet)\n            .filter(isNotKey)\n            .map(function(col) { return value(o, col); });\n          values.push(o['_' + f.key]); // for WHERE clause\n          return self.exec(tx, 'UPDATE OR IGNORE ' + f.tableName + ' SET ' + assignments + ' WHERE ' + f.key + '=?', values, function (tx, results) {\n            var changes = results.rowsAffected !== 0;\n            return callback ? callback(changes) : changes;\n          });\n        }\n\n        var upsert = function (o) {\n          var p;\n          if (o._isInDb) {\n            p = update(o, function (changed) { return changed ? insertSets(o, false) : insert(o); });\n          } else {\n            p = insert(o, function (changed) { return changed ? insertSets(o, true) : update(o); });\n          }\n          return p\n          .then(function (changed) {\n            console.assert(changed);\n            if(changed) {\n              o.clearChanges();\n              o._isInDb = true;\n            }\n          });\n        };\n\n        return Promise.all(objects.map(upsert)).then(resolve, reject);\n      });\n    });\n  };\n};\n\n\nmodule.exports = Store;\n","'use strict';\n\nfunction startsWith(str, val) {\n  return str.lastIndexOf(val, 0) === 0;\n}\n\n\nfunction clone(obj) {\n  var copy;\n\n  // Handle the 3 simple types, and null or undefined\n  if (null === obj || \"object\" !== typeof obj) {\n    return obj;\n  }\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i]);\n    }\n    return copy;\n  }\n\n  // Handle Object\n  if (obj instanceof Object) {\n    copy = {};\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = clone(obj[attr]);\n      }\n    }\n    return copy;\n  }\n\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\n\nfunction keyOf(obj) {\n  if(typeof(obj.key) === 'function') {\n    return obj.key();\n  }\n  return obj;\n}\n\n\nmodule.exports.startsWith = startsWith;\nmodule.exports.clone = clone;\nmodule.exports.keyOf = keyOf;"]}