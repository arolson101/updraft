{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"updraft.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\n/* updraft main */\r\n// TODO\r\n//  lists\r\n\r\n/**\r\n * Namespace for Updraft objects\r\n * @namespace\r\n */\r\nvar Updraft = {};\r\n\r\n\r\nfunction startsWith(str, val) {\r\n  return str.lastIndexOf(val, 0) === 0;\r\n}\r\n\r\n\r\nfunction clone(obj) {\r\n  var copy;\r\n\r\n  // Handle the 3 simple types, and null or undefined\r\n  if (null === obj || \"object\" !== typeof obj) {\r\n    return obj;\r\n  }\r\n\r\n  // Handle Array\r\n  if (obj instanceof Array) {\r\n    copy = [];\r\n    for (var i = 0, len = obj.length; i < len; i++) {\r\n      copy[i] = clone(obj[i]);\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  // Handle Object\r\n  if (obj instanceof Object) {\r\n    copy = {};\r\n    for (var attr in obj) {\r\n      if (obj.hasOwnProperty(attr)) {\r\n        copy[attr] = clone(obj[attr]);\r\n      }\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\");\r\n}\r\n\r\n\r\n/**\r\n * Column types.  Ignore the values; only use the keys.  Note that these are just column\r\n * affinities, and technically any value type can be stored in any column type.\r\n * see {@link https://www.sqlite.org/datatype3.html}\r\n *\r\n * @enum {string}\r\n * @readonly\r\n */\r\nvar columnType = {\r\n  'int': 'INTEGER',\r\n  'bool': 'BOOL',\r\n  'real': 'REAL',\r\n  'text': 'TEXT',\r\n  'blob': 'BLOB',\r\n  'date': 'DATE',\r\n  'datetime': 'DATETIME',\r\n  'json': 'TEXT',\r\n\r\n  /** points to an object in another table.  Its affinity will be that table's key's affinity */\r\n  'ptr': 'ref',\r\n\r\n  /** list of ptr */\r\n  'list': 'ref',\r\n};\r\n\r\n\r\n/**\r\n * The class template used by {@link Updraft.Store#createClass}.\r\n *\r\n * @typedef\r\n * @name ClassTemplate\r\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\r\n * @property {bool} [recreate=false] - whether the table should be recreated (dropped) if it exists.  All data will be lost.\r\n * @property {bool} [temp=false] - whether the table should be created as temporary (will not persist)\r\n * @property {Object} columns - an object describing the fields of objects of this type\r\n * @property {string} columns.key - name of the field\r\n * @property {object} columns.value\r\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\r\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\r\n * @property {bool} [columns.value.index=false] - create an index on this field\r\n * @property {object} [renamedColumns] - old column name is the key, new column name is the value\r\n * @example\r\n *  {\r\n *    tableName: 'users',\r\n *    columns: {\r\n *      'id': { key: true, type: 'int' },\r\n *      'name': { type: 'text' },\r\n *      'address3': { type: 'text' }\r\n *    },\r\n *    renamedColumns: {\r\n *      // migrate 'address2' column data into column 'address3'\r\n *      // the column must be specified in 'columns'\r\n *      'address2': 'address3'\r\n *    }\r\n *  }\r\n */\r\n\r\n\r\n/**\r\n * Interface for creating classes & database interaction\r\n *\r\n * @class\r\n * @property {bool} [logSql=false] - log sql statements to console.log\r\n */\r\nUpdraft.Store = function () {\r\n  var self = this;\r\n  this.tables = [];\r\n  this.triggers = {};\r\n  this.logSql = false;\r\n\r\n  //  this.listTable = {\r\n  //    tableName: '_updraft_lists',\r\n  //    columns: {\r\n  //      'tableName': {type: 'TEXT'},\r\n  //      'key': {type: 'TEXT'},\r\n  //      'member': {type: 'TEXT'},\r\n  //      'index': {type: 'INTEGER'},\r\n  //      'value': {type: 'TEXT'},\r\n  //    },\r\n  //    indices: [\r\n  //      ['tableName', 'key', 'member']\r\n  //    ]\r\n  //  };\r\n  //  this.tables.push(this.listTable);\r\n  \r\n  /**\r\n   * Example class, a {@link ClassFactory} returned by {@link Updraft.Store#createClass}\r\n   *\r\n   * @class\r\n   * @name ExampleClass\r\n   * @param {int} keyField - object's primary key, unique in the table\r\n   * @param {string} stringField\r\n   * @param {object} jsonField - can be any javascript type, object, or nesting of objects.  Will be \r\n   *        stored stringified, so any shared properties will no longer be shared after reloading from db.\r\n   * @param {int} indexedField - a regular integer field, but queries testing indexed fields will be faster\r\n   * @param childField - a pseudo 'ChildClass' object.  Although you can assign to it, the object won't be available.\r\n   *        That is, you will always need to call 'childField.get()' and wait for the promise, even if you just\r\n   *        assigned to it.\r\n   * @param {int} childField.id - the key of the child object pointed to.  Note that the member 'id' is because \r\n   *        ChildClass's key is named 'id'; similarly the type is inherited from ChildClass's key type.  This \r\n   *        is the only part of the reference that is stored on the object.\r\n   * @see ClassTemplate, ClassFactory\r\n   * @example\r\n   *  var ChildClass = store.createClass({\r\n   *    tableName: 'childClass',\r\n   *    columns: {\r\n   *      id: { type: 'int', key: true },\r\n   *      intField: { type: 'int', index: true }\r\n   *    }\r\n   *  });\r\n   *  var ExampleClass = store.createClass({\r\n   *    tableName: 'exampleClass',\r\n   *    columns: {\r\n   *      keyField: { type: 'int', key: true },\r\n   *      stringField: { type: 'text' },\r\n   *      jsonField: { type: 'json' },\r\n   *      indexedField: { type: 'int', index: true },\r\n   *      childField: { type: 'ptr', ref: ChildClass }\r\n   *    }\r\n   *  });\r\n   *\r\n   *  var child = new ChildClass({id: 321, intField: 456});\r\n   *\r\n   *  var x = new ExampleClass();\r\n   *  x.keyField = 123;\r\n   *  x.stringField = 'string example';\r\n   *  x.jsonField = { x: 1, y: 'a', z: { foo: 'bar' } };\r\n   *  console.log(x.changes());\r\n   *  // -> ['keyField', 'stringField', 'jsonField']\r\n   *\r\n   *  // the following lines are exactly equivalent:\r\n   *  x.childField = child;\r\n   *  x.childField = child.id;\r\n   *  x.childField = 321;\r\n   *\r\n   *  console.log(x.childField.id); // -> 321\r\n   *\r\n   *  x.childField.get().then(function(c) {\r\n   *    // child was never saved, so c is null, unless there was\r\n   *    // already a ChildClass with id=321 in the db');\r\n   *  });\r\n   *\r\n   *  // ... assume more objects have been created and saved ...\r\n   *\r\n   *  ExampleClass.all.where('childField.intField', '=', 456).get()\r\n   *  .then(function(results) {\r\n   *    // results is an array containing (a copy of) x and anything\r\n   *    // else that has the same \r\n   *  });\r\n   */\r\n\r\n  \r\n  /**\r\n   * Create a class.  Instances of this class are the only objects that can be stored.  Implicitly creates\r\n   * the associated table.\r\n   *\r\n   * @param {ClassTemplate} templ - A class template\r\n   * @return {ClassFactory} class factory\r\n   */\r\n  this.createClass = function (templ) {\r\n    console.assert(templ.tableName);\r\n    console.assert(templ.tableName[0] !== '_');\r\n    console.assert(templ.columns);\r\n    console.assert(Object.keys(templ.columns).length < 64);\r\n    console.assert(!('changes' in templ.columns));\r\n    console.assert(!('template' in templ.columns));\r\n    console.assert(!templ.renamedColumns || Object.keys(templ.renamedColumns).every(function (old) { return !(old in templ.columns); }));\r\n\r\n    /**\r\n     * Instances of this type will have properties for all the columns defined in {@link Store#createClass}.\r\n     * You can add additional properties, but they will not be saved.  Object will track which properties have changed\r\n     * since the last save.  Fields of type 'ptr' will return an object { [table's key]:[value], get: [function returning promise evaluating to object] }\r\n     *\r\n     * @class\r\n     * @name ClassFactory\r\n     * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\r\n     * @property {bool} [recreate=false] - whether the table should be recreated (dropped) if it exists.  All data will be lost.\r\n     * @property {bool} [temp=false] - whether the table should be created as temporary (will not persist)\r\n     * @property {Object} columns - an object describing the fields of objects of this type\r\n     * @property {string} columns.key - name of the field\r\n     * @property {object} columns.value\r\n     * @property {columnType} columns.value.type - 'int', 'bool', etc.\r\n     * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\r\n     * @property {bool} [columns.value.index=false] - create an index on this field\r\n     * @property {object} [renamedColumns] - old column name is the key, new column name is the value\r\n     * @property {QueryBuilder} all - use to construct a query\r\n     * @see ExampleClass\r\n     */\r\n    var Factory = function (props) {\r\n      var o = this;\r\n      o._changes = 0;\r\n      Object.keys(templ.columns).forEach(function(col) {\r\n        if(templ.columns[col].type === 'list') {\r\n          o['_' + col] = [];\r\n\r\n          // allow client to do object.field.push(otherobject); we'll transform it to object.field.push(otherobject.key())\r\n          o['_' + col].push = function() {\r\n            var args = Array.prototype.slice.call(arguments).map(function(arg) {\r\n              if(typeof arg === 'object') {\r\n                return arg.key();\r\n              } else {\r\n                return arg;\r\n              }\r\n            });\r\n            var array = o['_' + col];\r\n            var ret = Array.prototype.push.apply(array, args);\r\n            o[col] = array; // this will mark it dirty\r\n            return ret;\r\n          };\r\n        }\r\n      });\r\n      props = props || {};\r\n      for (var key in props) {\r\n        o[key] = props[key];\r\n      }\r\n    };\r\n\r\n    for (var key in templ) {\r\n      Factory[key] = clone(templ[key]);\r\n    }\r\n\r\n    Factory.key = null;\r\n    Factory.keyType = null;\r\n    Factory.indices = Factory.indices || [];\r\n\r\n    Object.keys(Factory.columns).forEach(function (col) {\r\n      if (Factory.columns[col].key) {\r\n        Factory.key = col;\r\n        Factory.keyType = Factory.columns[col].type;\r\n      }\r\n      if (Factory.columns[col].index) {\r\n        Factory.indices.push([col]);\r\n      }\r\n    });\r\n\r\n    console.assert(Factory.key);\r\n\r\n\r\n    /**\r\n     * Get a single object from database by its key\r\n     *\r\n     * @method\r\n     * @name ClassFactory.get\r\n     * @param id - value to find in table's primary key\r\n     * @returns {Promise<object>} Promise that resolves with element or null if not found\r\n     * @example\r\n     *  Class.get(123).then(function(obj) {\r\n     *    if(obj) {\r\n     *      console.log('found object 123:', obj);\r\n     *    } else {\r\n     *      console.log('object 123 was not in db');\r\n     *    }\r\n     *  });\r\n     */\r\n    Factory.get = function (id) {\r\n      return Factory.all.where(Factory.key, '=', id).get()\r\n      .then(function(results) {\r\n        console.assert(results.length < 2);\r\n        if(results.length === 0) {\r\n          return null;\r\n        } else {\r\n          return results[0];\r\n        }\r\n      });\r\n    };\r\n\r\n    Factory.prototype.factory = Factory;\r\n    \r\n\r\n    Factory.prototype.key = function() {\r\n      var key = '_' + Factory.key;\r\n      console.assert(key in this);\r\n      return this[key];\r\n    };\r\n\r\n    /**\r\n     * Get the fields that have been changed since the object was last loaded/saved\r\n     *\r\n     * @method\r\n     * @name ClassFactory#changes\r\n     * @returns {string[]} Names of the fields that have changed\r\n     * @example\r\n     *  var x = new Class();\r\n     *  x.foo = 'bar';\r\n     *  console.log(x.changes());\r\n     *  // -> ['foo']\r\n     */\r\n    Factory.prototype.changes = function () {\r\n      var changes = [];\r\n      var propIdx = 0;\r\n      for (var col in Factory.columns) {\r\n        var propMask = (1 << propIdx++);\r\n        if (this._changes & propMask) {\r\n          changes.push(col);\r\n        }\r\n      }\r\n      return changes;\r\n    };\r\n\r\n    \r\n    var addClassProperty = function(factory, col, propMask) {\r\n      var prop = '_' + col;\r\n\r\n      switch(Factory.columns[col].type) {\r\n        default:\r\n          Object.defineProperty(factory.prototype, col, {\r\n            get: function () {\r\n              return this[prop];\r\n            },\r\n            set: function (val) {\r\n              if (this[prop] !== val) {\r\n                this[prop] = val;\r\n                this._changes |= propMask;\r\n              }\r\n            }\r\n          });\r\n          break;\r\n\r\n        case 'ptr':\r\n          Object.defineProperty(factory.prototype, col, {\r\n            get: function () {\r\n              var ref = Factory.columns[col].ref;\r\n              console.assert(ref.get);\r\n              var ret = {};\r\n              ret.ref = ref;\r\n              ret.own = this;\r\n              ret[ref.key] = this[prop];\r\n              ret.get = function () { return this.ref.get(this.own[prop]); };\r\n              return ret;\r\n            },\r\n            set: function (val) {\r\n              // allow client to do object.field = otherobject; we'll transform it to object.field = otherobject.key()\r\n              if(typeof val === 'object') {\r\n                val = val.key();\r\n              }\r\n              if (this[prop] !== val) {\r\n                this[prop] = val;\r\n                this._changes |= propMask;\r\n              }\r\n            }\r\n          });\r\n          break;\r\n\r\n        case 'list':\r\n          Object.defineProperty(factory.prototype, col, {\r\n            get: function() {\r\n              return this[prop];\r\n            },\r\n            set: function(val) {\r\n              // allow client to do object.field = [otherobject]; we'll transform it to object.field = [otherobject.key()]\r\n              val = val.map(function(arg) {\r\n                if(typeof arg === 'object') {\r\n                  return arg.key();\r\n                } else {\r\n                  return arg;\r\n                }\r\n              });\r\n              this[prop] = val;\r\n              this._changes |= propMask;\r\n            }\r\n          });\r\n          break;\r\n      }\r\n    };\r\n\r\n    var propIdx = 0;\r\n    for (var col in Factory.columns) {\r\n      var propMask = (1 << propIdx++);\r\n      addClassProperty(Factory, col, propMask);\r\n      if (propIdx >= 63) {\r\n        throw new Error(\"class has too many columns- max 63\");\r\n      }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * construct object from a database result row\r\n     *\r\n     * @param {SQLRow} row\r\n     * @return instance of Factory with fields initialized according to row, with _isInDb=true and no changes set\r\n     * @private\r\n     */\r\n    Factory.constructFromDb = function(row) {\r\n      var o = new Factory();\r\n      for(var col in row) {\r\n        var val = row[col];\r\n        var _col = '_' + col;\r\n        switch(Factory.columns[col].type) {\r\n          case 'json':\r\n            o[_col] = JSON.parse(val);\r\n            break;\r\n          case 'list':\r\n            o[_col].push(val);\r\n            break;\r\n          default:\r\n            o[_col] = val;\r\n            break;\r\n        }\r\n      }\r\n\r\n      o._isInDb = true;\r\n      return o;\r\n    };\r\n\r\n\r\n    /**\r\n     * Get all objects of this type from database\r\n     *\r\n     * @method\r\n     * @name ClassFactory.all\r\n     * @returns {Promise<object[]>} Promise that resolves with (possibly empty) array of all objects of this type\r\n     * @example\r\n     *  Class.all().then(function(results) {\r\n     *    console.log('all objects in db:', results);\r\n     *  });\r\n     */\r\n    Factory.all = function () {\r\n      return Factory.all.get();\r\n    };\r\n    \r\n    Object.defineProperty(Factory, 'all', {\r\n      get: function() {\r\n        var props = {\r\n          count: false,\r\n          tables: [Factory.tableName],\r\n          columns: [],\r\n          conditions: [],\r\n          order: undefined,\r\n          asc: true,\r\n          nocase: false,\r\n        };\r\n        \r\n        // add child tables\r\n        for(var col in Factory.columns) {\r\n          if(Factory.columns[col].type !== 'list') {\r\n            props.columns.push(Factory.tableName + '.' + col);\r\n          }\r\n        }\r\n        \r\n        /**\r\n         * @class\r\n         * @name QueryBuilder\r\n         */\r\n        var all = function() {\r\n          return all.get();\r\n        };\r\n        \r\n        var addCondition = function(conj, col, op, val) {\r\n          var fields = col.split(/\\./);\r\n            var f = Factory;\r\n            for(var i=0; i<fields.length - 1; i++) {\r\n              var field = fields[i];\r\n              console.assert(field in f.columns);\r\n              var ref = f.columns[field].ref;\r\n              console.assert(ref);\r\n              if(props.tables.indexOf(ref.tableName)) {\r\n                props.tables.push(ref.tableName);\r\n                props.conditions.push({\r\n                  conj: 'AND',\r\n                  col: f.tableName + '.' + field,\r\n                  op: '=',\r\n                  val: ref.tableName + '.' + ref.key\r\n                });\r\n              }\r\n              f = ref;\r\n            }\r\n            props.conditions.push({\r\n              conj: conj,\r\n              col: f.tableName + '.' + fields[fields.length - 1],\r\n              op: op,\r\n              val: '?',\r\n              arg: val\r\n            });\r\n          return all;\r\n        };\r\n        \r\n        /**\r\n         * Adds an 'AND' condition to the query\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#and\r\n         * @param {string} col - column field to match on\r\n         * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\r\n         * @param val - value to match against {@linkcode col}\r\n         * @return {QueryBuilder}\r\n         * @see QueryBuilder#or\r\n         * @example\r\n         *  return Class.all.where('col2', '>', 10).and('col2', '<', 30).get();\r\n         *  // -> SELECT ... WHERE col2 > 10 AND col2 < 30\r\n         */\r\n        all.and = function(col, op, val) {\r\n          return addCondition('AND', col, op, val);\r\n        };\r\n        \r\n        /**\r\n         * alias for {@link QueryBuilder#and}\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#where\r\n         * @return {QueryBuilder}\r\n         * @example\r\n         *  return Class.all.where('col2', '>', 10).get();\r\n         */\r\n        all.where = all.and;\r\n        \r\n        /**\r\n         * Adds an 'OR' condition to the query\r\n         * @method\r\n         * @name QueryBuilder#or\r\n         * @param {string} col - column field to match on\r\n         * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\r\n         * @param val - value to match against {@linkcode col}\r\n         * @return {QueryBuilder}\r\n         * @see QueryBuilder#and\r\n         * @example\r\n         *  return Class.all.where('col2', '=', 10).and('col2', '=', 30).get();\r\n         *  // -> SELECT ... WHERE col2 = 10 OR col2 = 30\r\n         */\r\n        all.or = function(col, op, val) {\r\n          return addCondition('OR', col, op, val);\r\n        };\r\n        \r\n        /**\r\n         * Sort the results by specified field\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#order\r\n         * @param {string} col - column to sort by\r\n         * @param {bool} [asc=true] - sort ascending (true, default) or descending (false)\r\n         * @return {QueryBuilder}\r\n         * @see QueryBuilder#nocase\r\n         * @example\r\n         *  return Class.all.order('x').get();\r\n         *  // -> SELECT ... ORDER BY x\r\n         */\r\n        all.order = function(col, asc) {\r\n          props.order = col;\r\n          if(typeof asc !== 'undefined') {\r\n            props.asc = asc;\r\n          }\r\n          return all;\r\n        };\r\n        \r\n        /**\r\n         * Changes the match collation to be case-insensitive.  Only applies to result sorting, as 'LIKE' is \r\n         * always case-insensitive\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#nocase\r\n         * @return {QueryBuilder}\r\n         * @see QueryBuilder#order\r\n         * @example\r\n         *  return Class.all.order('x').nocase().get();\r\n         *  // -> SELECT ... ORDER BY x COLLATE NOCASE\r\n         */\r\n        all.nocase = function() {\r\n          props.nocase = true;\r\n          return all;\r\n        };\r\n        \r\n        \r\n        /**\r\n         * Executes the query, returning a promise resolving with the count of objects that match\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#count\r\n         * @return {Promise<int>}\r\n         * @see QueryBuilder#get\r\n         * @example\r\n         *  return Class.all.count()\r\n         *  .then(function(count) { console.log(count + \" objects\") });\r\n         *  // -> SELECT COUNT(*) FROM ...\r\n         */\r\n        all.count = function() {\r\n          props.count = true;\r\n          return all.get();\r\n        };\r\n        \r\n        \r\n        /**\r\n         * Executes the query, returning a promise resolving with the array of objects that match any conditions\r\n         * set on the QueryBuilder\r\n         *\r\n         * @method\r\n         * @name QueryBuilder#get\r\n         * @return {Promise<object[]>}\r\n         * @see QueryBuilder#count\r\n         * @example\r\n         *  return Class.all.where('x', '>', 0).get();\r\n         *  // -> SELECT ... WHERE x > 0\r\n         */\r\n        all.get = function() {\r\n          var countProp = 'COUNT(*)';\r\n          var stmt = 'SELECT ';\r\n          if(props.count) {\r\n            stmt += countProp;\r\n          } else {\r\n            stmt += props.columns.join(', ');\r\n          }\r\n          stmt += ' FROM ' + props.tables.join(', ');\r\n          var args = [];\r\n          for(var i=0; i<props.conditions.length; i++) {\r\n            var cond = props.conditions[i];\r\n            stmt += (i === 0) ? ' WHERE ' : (' ' + cond.conj + ' ');\r\n            stmt += cond.col + ' ' + cond.op + ' ' + cond.val;\r\n            if('arg' in cond) {\r\n              args.push(cond.arg);\r\n            }\r\n          }\r\n          if(props.order) {\r\n            stmt += ' ORDER BY ' + props.order;\r\n            stmt += (props.nocase ? ' COLLATE NOCASE' : '');\r\n            stmt += (props.asc ? ' ASC' : ' DESC');\r\n          }\r\n          \r\n          var objects = [];\r\n          return self.execRead(stmt, args, function (tx, results) {\r\n            if(props.count) {\r\n              return results.rows.item(0)[countProp];\r\n            }\r\n            for (var i = 0; i < results.rows.length; i++) {\r\n              var o = Factory.constructFromDb(results.rows.item(i));\r\n              objects.push(o);\r\n            }\r\n            return Promise.all(objects.map(function(o) {\r\n              return Promise.all(\r\n                Object.keys(Factory.columns)\r\n                .filter(function(col) {\r\n                  return (Factory.columns[col].type === 'list');\r\n                })\r\n                .map(function(col) {\r\n                  var listTable = Factory.columns[col].listTable;\r\n                  console.assert(listTable);\r\n                  var key = o.key();\r\n                  var s = 'SELECT ' + col;\r\n                  s += ' FROM ' + listTable.tableName;\r\n                  s += ' WHERE ' + Factory.key + ' = ?';\r\n                  return self.exec(tx, s, [key], function(tx, results) {\r\n                    for(var i=0; i<results.rows.length; i++) {\r\n                      var row = results.rows.item(i);\r\n                      o['_' + col].push(row[col]);\r\n                    }\r\n                    o._changes = 0;\r\n                  });\r\n                })\r\n              );\r\n            }))\r\n            .then(function() {\r\n              return objects;\r\n            });\r\n          });\r\n        };\r\n\r\n        return all;\r\n      }\r\n    });\r\n\r\n\r\n    self.tables.push(Factory);\r\n\r\n    return Factory;\r\n  };\r\n  \r\n  /**\r\n   * delete all tables in database\r\n   */\r\n  this.purge = function(opts) {\r\n    console.assert(!self.db);\r\n\r\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\r\n    console.assert(self.db);\r\n    return self.readSchema()\r\n      .then(function(schema) {\r\n        return new Promise(function(fulfill, reject) {\r\n          self.db.transaction(function(tx) {\r\n            var p = Promise.resolve();\r\n            Object.keys(schema).forEach(function(table) {\r\n              p = p.then(self.exec(tx, 'DROP TABLE ' + table));\r\n            });\r\n            return p.then(function() {\r\n              self.db = null;\r\n            })\r\n            .then(fulfill, reject);\r\n          });\r\n        });\r\n      });\r\n  };\r\n\r\n\r\n  /**\r\n   * open the database\r\n   *\r\n   * @param {object} opts options for creating the db\r\n   * @param {string} opts.name name of db to be created\r\n   * @return {Promise} a promise that resolves with no parameters when the database is created and ready\r\n   * @example\r\n   *    store.open({name: 'my cool db'}).then(function() {\r\n   *      // start loading & saving objects\r\n   *    });\r\n   */\r\n  this.open = function (opts) {\r\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\r\n    console.assert(self.db);\r\n    \r\n    // add list tables\r\n    var listTables = [];\r\n    for(var i=0; i<self.tables.length; i++) {\r\n      var table = self.tables[i];\r\n      for(var col in table.columns) {\r\n        if(table.columns[col].type === 'list') {\r\n          var ref = table.columns[col].ref;\r\n          console.assert(ref);\r\n          var listTable = {};\r\n          listTable.tableName = table.tableName + '_' + col;\r\n          listTable.recreate = table.recreate;\r\n          listTable.temp = table.temp;\r\n          listTable.key = '';\r\n          listTable.keyType = table.keyType;\r\n          listTable.columns = {};\r\n          listTable.columns[table.key] = { type: table.keyType }; // note: NOT setting key=true, as it would impose unique constraint\r\n          listTable.columns[col] = { type: ref.keyType };\r\n          listTable.indices = [ [table.key], [col] ];\r\n          table.columns[col].listTable = listTable;\r\n          listTables.push(listTable);\r\n        }\r\n      }\r\n    }\r\n    \r\n    self.tables = self.tables.concat(listTables);\r\n    \r\n    return self.readSchema()\r\n            .then(syncTables);\r\n  };\r\n\r\n\r\n  /**\r\n   * close the database\r\n   */\r\n  this.close = function () {\r\n    self.db = null;\r\n    self.tables = [];\r\n    self.triggers = {};\r\n  };\r\n\r\n\r\n  /**\r\n   * convenience function to log a message after promise resolves\r\n   *\r\n   * @param message - message to log\r\n   * @private\r\n   */\r\n  //  function report(message) {\r\n  //    return function() {\r\n  //      console.log(message);\r\n  //    };\r\n  //  }\r\n\r\n  /**\r\n   * exec a sql statement within a given transaction\r\n   *\r\n   * @param {SQLTransaction} tx - a transaction created by <tt>db.transaction</tt> or <tt>db.readTransaction</tt>\r\n   * @param {string} stmt - sql statement to execute\r\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\r\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\r\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\r\n   * @private\r\n   */\r\n  this.exec = function(tx, stmt, args, callback) {\r\n    if(self.logSql) {\r\n      console.log(stmt, args);\r\n    }\r\n    return new Promise(function (fulfill, reject) {\r\n      try {\r\n        tx.executeSql(stmt, args,\r\n                      function (tx, results) {\r\n                        var ret = callback ? callback(tx, results) : null;\r\n                        return Promise.resolve(ret).then(fulfill, reject);\r\n                      },\r\n                      function (tx, error) {\r\n                        reportError(error);\r\n                        reject(error);\r\n                      });\r\n      } catch (reason) {\r\n        console.log('Failed to exec \"' + stmt + '\":' + reason);\r\n        throw reason;\r\n      }\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * exec a sql statement within a new read transaction\r\n   *\r\n   * @param {string} stmt - sql statement to execute\r\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\r\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\r\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\r\n   * @private\r\n   */\r\n  this.execRead = function(stmt, args, callback) {\r\n    console.assert(self.db);\r\n    return new Promise(function (fulfill, reject) {\r\n      self.db.readTransaction(function (rtx) {\r\n        return self.exec(rtx, stmt, args, callback)\r\n                .then(fulfill, reject);\r\n      });\r\n    });\r\n  };\r\n\r\n\r\n  function reportError(error) {\r\n    switch (error.code) {\r\n      case error.SYNTAX_ERR:\r\n        console.log(\"Syntax error: \" + error.message);\r\n        break;\r\n      default:\r\n        console.log(error);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Database schema.  The outer keys will be the tables in the database.  The values will consist of an\r\n   * object whose keys will be the table's rows and values will be the row's type.  It will also have an\r\n   * '_indices' object with all the indices found.\r\n   * Note: tables or indices beginning with underscore or 'sqlite' will be ignored\r\n   *\r\n   * @typedef\r\n   * @name Schema\r\n   * @example\r\n   *    var schema = {\r\n   *      'todos': {\r\n   *        _indices: {\r\n   *          'index_todos__name': 'CREATE INDEX ...',\r\n   *        },\r\n   *        _triggers: {\r\n   *          'trigger_todos__task': 'CREATE TRIGGER ...',\r\n   *        },\r\n   *        'id': 'INTEGER PRIMARY KEY',\r\n   *        'name': 'TEXT',\r\n   *      },\r\n   *      'tasks': {\r\n   *        'id': 'INTEGER PRIMARY KEY',\r\n   *        'description': 'TEXT',\r\n   *      }\r\n   *    };\r\n   */\r\n\r\n\r\n  /**\r\n   * get the existing database's schema in object form\r\n   *\r\n   * @return {Promise} a promise that resolves with the {@link Schema}\r\n   */\r\n  this.readSchema = function () {\r\n    function tableFromSql(sql) {\r\n      var table = { _indices: {}, _triggers: {} };\r\n      var matches = sql.match(/\\((.*)\\)/);\r\n      if (matches) {\r\n        var fields = matches[1].split(',');\r\n        for (var i = 0; i < fields.length; i++) {\r\n          var ignore = /^\\s*(primary|foreign)\\s+key/i;  // ignore standalone 'PRIMARY KEY xxx'\r\n          if (fields[i].match(ignore)) {\r\n            continue;\r\n          }\r\n          var quotedName = /\"(.+)\"\\s+(.*)/;\r\n          var unquotedName = /(\\w+)\\s+(.*)/;\r\n          var parts = fields[i].match(quotedName);\r\n          if (!parts) {\r\n            parts = fields[i].match(unquotedName);\r\n          }\r\n          if (parts) {\r\n            table[parts[1]] = parts[2];\r\n          }\r\n        }\r\n      }\r\n      return table;\r\n    }\r\n\r\n    return self.execRead('SELECT name, tbl_name, type, sql FROM sqlite_master', [], function (tx, results) {\r\n      /*jshint camelcase:false*/\r\n      var schema = {};\r\n      for (var i = 0; i < results.rows.length; i++) {\r\n        var row = results.rows.item(i);\r\n        if (row.name[0] != '_' && !startsWith(row.name, 'sqlite')) {\r\n          switch (row.type) {\r\n            case 'table':\r\n              schema[row.name] = tableFromSql(row.sql);\r\n              break;\r\n            case 'index':\r\n              schema[row.tbl_name]._indices = schema[row.tbl_name]._indices || {};\r\n              schema[row.tbl_name]._indices[row.name] = row.sql;\r\n              break;\r\n            case 'trigger':\r\n              schema[row.tbl_name]._triggers = schema[row.tbl_name]._triggers || {};\r\n              schema[row.tbl_name]._triggers[row.name] = row.sql;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n      return schema;\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Check whether the tables in the current database match up with the ClassFactories.\r\n   * They will be created or modified as needed.\r\n   *\r\n   * @param {Schema} schema\r\n   * @return {Promise} A promise that resolves with no parameters once all tables are up-to-date.\r\n   * @private\r\n   */\r\n  function syncTables(schema) {\r\n    console.assert(self.db);\r\n    return new Promise(function (fulfill, reject) {\r\n      self.db.transaction(function (tx) {\r\n        return Promise.all(self.tables.map(function (f) { return syncTable(tx, schema, f); }))\r\n          .then(fulfill, reject);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Check whether an individual table in the current database matches up with its corresponding ClassFactory.\r\n   * It will be created or modified as needed.\r\n   *\r\n   * @param {SQLTransaction} tx - a writeable transaction\r\n   * @param {Schema} schema\r\n   * @param {object} f - a {@link ClassFactory} or other object that describes a table\r\n   * @return {Promise} A promise that resolves with no parameters once the table is up-to-date.\r\n   * @private\r\n   */\r\n  function syncTable(tx, schema, f) {\r\n    // execute CREATE TABLE statement\r\n    function createTable(name) {\r\n      var cols = [];\r\n      for (var col in f.columns) {\r\n        var attrs = f.columns[col];\r\n        var decl;\r\n        console.assert(attrs.type in columnType);\r\n        switch (attrs.type) {\r\n          case 'ptr':\r\n            console.assert(attrs.ref);\r\n            console.assert(attrs.ref.columns);\r\n            console.assert(attrs.ref.tableName);\r\n            console.assert(attrs.ref.key);\r\n            var foreignType = attrs.ref.columns[attrs.ref.key].type;\r\n            console.assert(foreignType in columnType);\r\n            decl = col + ' ' + columnType[foreignType];\r\n            cols.push(decl);\r\n            break;\r\n            \r\n          case 'list':\r\n            break;\r\n\r\n          default:\r\n            console.assert(attrs.type in columnType);\r\n            decl = col + ' ' + columnType[attrs.type];\r\n            if (f.key === col) {\r\n              decl += ' PRIMARY KEY';\r\n            }\r\n            cols.push(decl);\r\n        }\r\n      }\r\n      return self.exec(tx, 'CREATE ' + (f.temp ? 'TEMP ' : '') + 'TABLE ' + name + ' (' + cols.join(', ') + ')');\r\n    }\r\n\r\n    function dropTable(name) {\r\n      return self.exec(tx, 'DROP TABLE ' + name);\r\n    }\r\n\r\n    function createIndices(force) {\r\n      var p = Promise.resolve();\r\n      var toRemove = (f.tableName in schema) ? clone(schema[f.tableName]._indices) : {};\r\n      f.indices.forEach(function (index) {\r\n        var name = 'index_' + f.tableName + '__' + index.join('_');\r\n        var sql = 'CREATE INDEX ' + name + ' ON ' + f.tableName + ' (' + index.join(', ') + ')';\r\n        delete toRemove[name];\r\n        var create = true;\r\n        var drop = false;\r\n        if (schema[f.tableName] && schema[f.tableName]._indices && schema[f.tableName]._indices[name]) {\r\n          if (schema[f.tableName]._indices[name] === sql) {\r\n            create = false;\r\n          } else {\r\n            drop = true;\r\n          }\r\n        }\r\n\r\n        if (drop) {\r\n          p = p.then(self.exec(tx, 'DROP INDEX ' + name));\r\n        }\r\n        if (create || force) {\r\n          p = p.then(self.exec(tx, sql));\r\n        }\r\n      });\r\n\r\n      // delete orphaned indices\r\n      Object.keys(toRemove).forEach(function (name) {\r\n        p = p.then(self.exec(tx, 'DROP INDEX ' + name));\r\n      });\r\n      return p;\r\n    }\r\n\r\n    // check if table already exists\r\n    if (f.tableName in schema) {\r\n      if (f.recreate) {\r\n        return Promise.resolve()\r\n          .then(dropTable(f.tableName))\r\n          .then(createTable(f.tableName))\r\n          .then(createIndices(true));\r\n      } else {\r\n        //console.log(\"table \" + f.tableName + \" exists; checking columns\");\r\n        var columns = clone(schema[f.tableName]);\r\n        delete columns._indices;\r\n        delete columns._triggers;\r\n        var key;\r\n\r\n        var addedColumns = [];\r\n        var addedForeignKey = false;\r\n        for (key in f.columns) {\r\n          if (!(key in columns)) {\r\n            addedColumns.push(key);\r\n            if (f.columns[key].ref) {\r\n              addedForeignKey = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        var renamedColumns = clone(f.renamedColumns) || {};\r\n        for (key in Object.keys(renamedColumns)) {\r\n          if (!(key in columns)) {\r\n            delete renamedColumns[key];\r\n          }\r\n        }\r\n\r\n        var deletedColumns = Object.keys(columns).filter(function (col) {\r\n          return !(col in f.columns);\r\n        });\r\n\r\n        if (addedForeignKey || Object.keys(renamedColumns).length > 0 || deletedColumns.length > 0) {\r\n          // must recreate table and migrate data\r\n          var copyData = function (oldName, newName) {\r\n            var oldTableColumns = Object.keys(columns).filter(function (col) { return (col in f.columns) || (col in renamedColumns); });\r\n            var newTableColumns = oldTableColumns.map(function (col) { return (col in renamedColumns) ? renamedColumns[col] : col; });\r\n            var stmt = \"INSERT INTO \" + newName + \" (\" + newTableColumns.join(\", \") + \") \";\r\n            stmt += \"SELECT \" + oldTableColumns.join(\", \") + \" FROM \" + oldName + \";\";\r\n            return self.exec(tx, stmt);\r\n          };\r\n\r\n          var renameTable = function (oldName, newName) {\r\n            return self.exec(tx, 'ALTER TABLE ' + oldName + ' RENAME TO ' + newName);\r\n          };\r\n\r\n          var newTableName = 'new_' + f.tableName;\r\n          console.assert(!(newTableName in schema));\r\n\r\n          return Promise.resolve()\r\n            .then(createTable(newTableName))\r\n            .then(copyData(f.tableName, newTableName))\r\n            .then(dropTable(f.tableName))\r\n            .then(renameTable(newTableName, f.tableName))\r\n            .then(createIndices(true));\r\n\r\n        } else if (addedColumns.length > 0) {\r\n          // alter table, add columns\r\n          var p = Promise.resolve();\r\n          addedColumns.map(function (columnName) {\r\n            var attrs = f.columns[columnName];\r\n            console.assert(attrs.type in columnType);\r\n            var columnDecl = columnName + ' ' + columnType[attrs.type];\r\n            p = p.then(self.exec(tx, 'ALTER TABLE ' + f.tableName + ' ADD COLUMN ' + columnDecl));\r\n          });\r\n          return p\r\n            .then(createIndices());\r\n        } else {\r\n          // no table modification is required\r\n          return createIndices();\r\n        }\r\n      }\r\n    } else {\r\n      //console.log('creating table: ' + f.tableName);\r\n      return Promise.resolve()\r\n        .then(createTable(f.tableName))\r\n        .then(createIndices(true));\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Save all objects to database.  Atomic operation- all objects will be saved within the same transaction\r\n   * or nothing will be written.  Objects can be heterogeneous.\r\n   *\r\n   * @param {object[]} objects - array of instances of {@link ClassFactory}\r\n   */\r\n  this.save = function (objects) {\r\n    objects.map(function (o) {\r\n      console.assert(('_' + o.factory.key) in o, \"object must have a key\");\r\n    });\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      self.db.transaction(function (tx) {\r\n        function value(o, col) {\r\n          var val = o['_' + col];\r\n          if(typeof val === 'object') {\r\n            val = JSON.stringify(val);\r\n          }\r\n          return val;\r\n        }\r\n        \r\n        function insertLists(o, force) {\r\n          var changes = o.changes();\r\n          var f = o.factory;\r\n          var promises = [];\r\n          Object.keys(f.columns)\r\n          .filter(function(col) {\r\n            return (f.columns[col].type === 'list') && (force || changes.indexOf(col) > -1);\r\n          })\r\n          .forEach(function(col) {\r\n            var ref = f.columns[col].ref;\r\n            var listTable = f.columns[col].listTable;\r\n            console.assert(ref);\r\n            console.assert(listTable);\r\n            var values = o['_' + col];\r\n            var key = o[f.key];\r\n            promises.push( self.exec(tx, 'DELETE FROM ' + listTable.tableName + ' WHERE ' + f.key + '=?', [ key ]) );\r\n            values.forEach(function(value) {\r\n              promises.push( self.exec(tx, 'INSERT INTO ' + listTable.tableName + ' (' + f.key + ', ' + col + ') VALUES (?, ?)', [key, value]) );\r\n            });\r\n          });\r\n          return Promise.all(promises);\r\n        }\r\n        \r\n        function insert(o, callback) {\r\n          var f = o.factory;\r\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\r\n          var cols = Object.keys(f.columns).filter(isNotList);\r\n          var columns = cols.join(', ');\r\n          var values = cols.map(function () { return '?'; }).join(', ');\r\n          var args = cols.map(function(col) { return value(o, col); });\r\n          return self.exec(tx, 'INSERT OR IGNORE INTO ' + f.tableName + ' (' + columns + ') VALUES (' + values + ')', args, function (tx, results) {\r\n            var changes = results.rowsAffected !== 0;\r\n            return callback ? callback(changes) : changes;\r\n          });\r\n        }\r\n\r\n        function update(o, callback) {\r\n          var f = o.factory;\r\n          var cols = o.changes();\r\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\r\n          var isNotKey = function(col) { return col !== f.key; };\r\n          var assignments = cols\r\n            .filter(isNotList)\r\n            .filter(isNotKey)\r\n            .map(function (col) { return col + '=?'; })\r\n            .join(', ');\r\n          var values = cols\r\n            .filter(isNotList)\r\n            .filter(isNotKey)\r\n            .map(function(col) { return value(o, col); });\r\n          values.push(o['_' + f.key]); // for WHERE clause\r\n          return self.exec(tx, 'UPDATE OR IGNORE ' + f.tableName + ' SET ' + assignments + ' WHERE ' + f.key + '=?', values, function (tx, results) {\r\n            var changes = results.rowsAffected !== 0;\r\n            return callback ? callback(changes) : changes;\r\n          });\r\n        }\r\n\r\n        var upsert = function (o) {\r\n          var p;\r\n          if (o._isInDb) {\r\n            p = update(o, function (changed) { return changed ? insertLists(o, false) : insert(o); });\r\n          } else {\r\n            p = insert(o, function (changed) { return changed ? insertLists(o, true) : update(o); });\r\n          }\r\n          return p\r\n          .then(function (changed) {\r\n            console.assert(changed);\r\n            if(changed) {\r\n              o._changes = 0;\r\n              o._isInDb = true;\r\n            }\r\n          });\r\n        };\r\n\r\n//        var p = Promise.resolve();\r\n//        objects.forEach(function(o) {\r\n//          p = p.then(function() { return upsert(o) });\r\n//        });\r\n//        return p.then(resolve, reject); // Promise.all(objects.map(upsert)).then(resolve, reject);\r\n        return Promise.all(objects.map(upsert)).then(resolve, reject);\r\n      });\r\n    });\r\n  };\r\n\r\n};\r\n\r\n\r\n// Version.\r\nUpdraft.VERSION = '0.0.1';\r\n\r\n\r\nmodule.exports = Updraft;\r\n\r\nif (window) {\r\n  window.Updraft = Updraft;\r\n}\r\n"]}