{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.js","src/model.js","src/query.js","src/util.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"updraft.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\n/* updraft main */\r\n// TODO\r\n//  lists\r\n\r\n/**\r\n * @namespace Updraft\r\n */\r\nvar Updraft = {};\r\nUpdraft.VERSION = '0.4.0';\r\n\r\nvar util = require('./util');\r\nvar Model = require('./model');\r\nvar clone = util.clone;\r\nvar startsWith = util.startsWith;\r\n\r\n/**\r\n * Column types.  Ignore the values; only use the keys.  Note that these are just column\r\n * affinities, and technically any value type can be stored in any column type.\r\n * see {@link https://www.sqlite.org/datatype3.html}\r\n *\r\n * @enum {string}\r\n * @readonly\r\n */\r\nUpdraft.columnType = {\r\n  'int': 'INTEGER',\r\n  'bool': 'BOOL',\r\n  'real': 'REAL',\r\n  'text': 'TEXT',\r\n  'blob': 'BLOB',\r\n  'date': 'DATE',\r\n  'datetime': 'DATETIME',\r\n  \r\n  /** object will be serialized & restored as JSON text */\r\n  'json': 'TEXT',\r\n\r\n  /** points to an object in another table.  Its affinity will be that table's key's affinity */\r\n  'ptr': 'ref',\r\n\r\n  /** list of ptr */\r\n  'list': 'ref',\r\n};\r\n\r\nvar columnType = Updraft.columnType;\r\n\r\n/**\r\n * The class template used by {@link Updraft.Store#createClass}.\r\n *\r\n * @typedef\r\n * @name Updraft.ClassTemplate\r\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\r\n * @property {bool} [recreate=false] - whether the table should be recreated (dropped) if it exists.  All data will be lost.\r\n * @property {bool} [temp=false] - whether the table should be created as temporary (will not persist)\r\n * @property {Object} columns - an object describing the fields of objects of this type\r\n * @property {string} columns.key - name of the field\r\n * @property {object} columns.value\r\n * @property {columnType} columns.value.type - 'int', 'bool', etc.\r\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\r\n * @property {bool} [columns.value.index=false] - create an index on this field\r\n * @property {object} [renamedColumns] - old column name is the key, new column name is the value\r\n * @example\r\n *  {\r\n *    tableName: 'users',\r\n *    columns: {\r\n *      'id': { key: true, type: 'int' },\r\n *      'name': { type: 'text' },\r\n *      'address3': { type: 'text' }\r\n *    },\r\n *    renamedColumns: {\r\n *      // migrate 'address2' column data into column 'address3'\r\n *      // the column must be specified in 'columns'\r\n *      'address2': 'address3'\r\n *    }\r\n *  }\r\n */\r\n\r\n\r\n/**\r\n * The parameters used to open a database\r\n *\r\n * @typedef\r\n * @name Updraft.StoreOptions\r\n * @property {string} name - the name of the database to open\r\n */\r\n\r\n\r\n/**\r\n * Interface for creating classes & database interaction\r\n *\r\n * @class\r\n * @property {bool} [logSql=false] - log sql statements to console.log\r\n */\r\nvar Store = function () {\r\n  var self = this;\r\n  this.tables = [];\r\n  this.triggers = {};\r\n  this.logSql = false;\r\n\r\n  \r\n  /**\r\n   * create a new type whose instances can be stored in a database\r\n   * @param {Updraft.ClassTemplate} templ\r\n   * @return {Model}\r\n   * @see ExampleModel\r\n   * @example \r\n   *  var ExampleModel = store.createClass({\r\n   *    tableName: 'exampleModel',\r\n   *    columns: {\r\n   *      keyField: { type: 'int', key: true },\r\n   *      stringField: { type: 'text' },\r\n   *      jsonField: { type: 'json' },\r\n   *      indexedField: { type: 'int', index: true },\r\n   *      childField: { type: 'ptr', ref: ChildClass }\r\n   *    }\r\n   *  });\r\n   */\r\n  this.createClass = function(templ) {\r\n    var m = new Model(self, templ);\r\n    //var m = Model.createModel(self, templ);\r\n    self.tables.push(m);\r\n    return m;\r\n  };\r\n  \r\n\r\n  /**\r\n   * Delete all tables in database.  For development purposes; you probably don't want to ship with this.\r\n   *\r\n   * @global\r\n   * @typedef\r\n   * @param {Updraft.StoreOptions} opts\r\n   * @return {Promise} a promise that resolves when all tables are deleted\r\n   * @see Updraft.Store#open\r\n   * @example\r\n   *    store.purge({name: 'my cool db'}).then(function() {\r\n   *      // everything is gone\r\n   *    });\r\n   */\r\n  this.purge = function(opts) {\r\n    console.assert(!self.db);\r\n\r\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\r\n    console.assert(self.db);\r\n    return self.readSchema()\r\n      .then(function(schema) {\r\n        return new Promise(function(fulfill, reject) {\r\n          self.db.transaction(function(tx) {\r\n            var p = Promise.resolve();\r\n            Object.keys(schema).forEach(function(table) {\r\n              p = p.then(self.exec(tx, 'DROP TABLE ' + table));\r\n            });\r\n            return p.then(function() {\r\n              self.db = null;\r\n            })\r\n            .then(fulfill, reject);\r\n          });\r\n        });\r\n      });\r\n  };\r\n\r\n\r\n  /**\r\n   * open the database\r\n   *\r\n   * @param {Updraft.StoreOptions} opts\r\n   * @return {Promise} a promise that resolves with no parameters when the database is created and ready\r\n   * @example\r\n   *    store.open({name: 'my cool db'}).then(function() {\r\n   *      // start loading & saving objects\r\n   *    });\r\n   */\r\n  this.open = function (opts) {\r\n    self.db = window.openDatabase(opts.name, '1.0', 'updraft created database', 5 * 1024 * 1024);\r\n    console.assert(self.db);\r\n    \r\n    // add list tables\r\n    var listTables = [];\r\n    for(var i=0; i<self.tables.length; i++) {\r\n      var table = self.tables[i];\r\n      for(var col in table.columns) {\r\n        if(table.columns[col].type === 'list') {\r\n          var ref = table.columns[col].ref;\r\n          console.assert(ref);\r\n          var listTable = {};\r\n          listTable.tableName = table.tableName + '_' + col;\r\n          listTable.recreate = table.recreate;\r\n          listTable.temp = table.temp;\r\n          listTable.key = '';\r\n          listTable.keyType = table.keyType;\r\n          listTable.columns = {};\r\n          listTable.columns[table.key] = { type: table.keyType }; // note: NOT setting key=true, as it would impose unique constraint\r\n          listTable.columns[col] = { type: ref.keyType };\r\n          listTable.indices = [ [table.key], [col] ];\r\n          table.columns[col].listTable = listTable;\r\n          listTables.push(listTable);\r\n        }\r\n      }\r\n    }\r\n    \r\n    self.tables = self.tables.concat(listTables);\r\n    \r\n    return self.readSchema()\r\n            .then(syncTables);\r\n  };\r\n\r\n\r\n  /**\r\n   * close the database\r\n   */\r\n  this.close = function () {\r\n    self.db = null;\r\n    self.tables = [];\r\n    self.triggers = {};\r\n  };\r\n\r\n\r\n  /**\r\n   * exec a sql statement within a given transaction\r\n   *\r\n   * @param {SQLTransaction} tx - a transaction created by <tt>db.transaction</tt> or <tt>db.readTransaction</tt>\r\n   * @param {string} stmt - sql statement to execute\r\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\r\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\r\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\r\n   * @private\r\n   */\r\n  this.exec = function(tx, stmt, args, callback) {\r\n    if(self.logSql) {\r\n      console.log(stmt, args);\r\n    }\r\n    return new Promise(function (fulfill, reject) {\r\n      try {\r\n        tx.executeSql(stmt, args,\r\n                      function (tx, results) {\r\n                        var ret = callback ? callback(tx, results) : null;\r\n                        return Promise.resolve(ret).then(fulfill, reject);\r\n                      },\r\n                      function (tx, error) {\r\n                        reportError(error);\r\n                        reject(error);\r\n                      });\r\n      } catch (reason) {\r\n        console.log('Failed to exec \"' + stmt + '\":' + reason);\r\n        throw reason;\r\n      }\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * exec a sql statement within a new read transaction\r\n   *\r\n   * @param {string} stmt - sql statement to execute\r\n   * @param {string[]} args - array of strings to substitute into <tt>stmt</tt>\r\n   * @param {function} [callback=null] - callback with parameters (transaction, [SQLResultSet]{@link http://www.w3.org/TR/webdatabase/#sqlresultset})\r\n   * @return {Promise} a promise that resolves with (transaction, return value of the callback)\r\n   * @private\r\n   */\r\n  this.execRead = function(stmt, args, callback) {\r\n    console.assert(self.db);\r\n    return new Promise(function (fulfill, reject) {\r\n      self.db.readTransaction(function (rtx) {\r\n        return self.exec(rtx, stmt, args, callback)\r\n                .then(fulfill, reject);\r\n      });\r\n    });\r\n  };\r\n\r\n\r\n  function reportError(error) {\r\n    switch (error.code) {\r\n      case error.SYNTAX_ERR:\r\n        console.log(\"Syntax error: \" + error.message);\r\n        break;\r\n      default:\r\n        console.log(error);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Database schema.  The outer keys will be the tables in the database.  The values will consist of an\r\n   * object whose keys will be the table's rows and values will be the row's type.  It will also have an\r\n   * '_indices' object with all the indices found.\r\n   * Note: tables or indices beginning with underscore or 'sqlite' will be ignored\r\n   *\r\n   * @typedef\r\n   * @name Updraft.Schema\r\n   * @example\r\n   *    var schema = {\r\n   *      'todos': {\r\n   *        _indices: {\r\n   *          'index_todos__name': 'CREATE INDEX ...',\r\n   *        },\r\n   *        _triggers: {\r\n   *          'trigger_todos__task': 'CREATE TRIGGER ...',\r\n   *        },\r\n   *        'id': 'INTEGER PRIMARY KEY',\r\n   *        'name': 'TEXT',\r\n   *      },\r\n   *      'tasks': {\r\n   *        'id': 'INTEGER PRIMARY KEY',\r\n   *        'description': 'TEXT',\r\n   *      }\r\n   *    };\r\n   */\r\n\r\n\r\n  /**\r\n   * get the existing database's schema in object form\r\n   *\r\n   * @return {Promise} a promise that resolves with the {@link Updraft.Schema}\r\n   */\r\n  this.readSchema = function () {\r\n    function tableFromSql(sql) {\r\n      var table = { _indices: {}, _triggers: {} };\r\n      var matches = sql.match(/\\((.*)\\)/);\r\n      if (matches) {\r\n        var fields = matches[1].split(',');\r\n        for (var i = 0; i < fields.length; i++) {\r\n          var ignore = /^\\s*(primary|foreign)\\s+key/i;  // ignore standalone 'PRIMARY KEY xxx'\r\n          if (fields[i].match(ignore)) {\r\n            continue;\r\n          }\r\n          var quotedName = /\"(.+)\"\\s+(.*)/;\r\n          var unquotedName = /(\\w+)\\s+(.*)/;\r\n          var parts = fields[i].match(quotedName);\r\n          if (!parts) {\r\n            parts = fields[i].match(unquotedName);\r\n          }\r\n          if (parts) {\r\n            table[parts[1]] = parts[2];\r\n          }\r\n        }\r\n      }\r\n      return table;\r\n    }\r\n\r\n    return self.execRead('SELECT name, tbl_name, type, sql FROM sqlite_master', [], function (tx, results) {\r\n      /*jshint camelcase:false*/\r\n      var schema = {};\r\n      for (var i = 0; i < results.rows.length; i++) {\r\n        var row = results.rows.item(i);\r\n        if (row.name[0] != '_' && !startsWith(row.name, 'sqlite')) {\r\n          switch (row.type) {\r\n            case 'table':\r\n              schema[row.name] = tableFromSql(row.sql);\r\n              break;\r\n            case 'index':\r\n              schema[row.tbl_name]._indices = schema[row.tbl_name]._indices || {};\r\n              schema[row.tbl_name]._indices[row.name] = row.sql;\r\n              break;\r\n            case 'trigger':\r\n              schema[row.tbl_name]._triggers = schema[row.tbl_name]._triggers || {};\r\n              schema[row.tbl_name]._triggers[row.name] = row.sql;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n      return schema;\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Check whether the tables in the current database match up with the ClassFactories.\r\n   * They will be created or modified as needed.\r\n   *\r\n   * @param {Updraft.Schema} schema\r\n   * @return {Promise} A promise that resolves with no parameters once all tables are up-to-date.\r\n   * @private\r\n   */\r\n  function syncTables(schema) {\r\n    console.assert(self.db);\r\n    return new Promise(function (fulfill, reject) {\r\n      self.db.transaction(function (tx) {\r\n        return Promise.all(self.tables.map(function (f) { return syncTable(tx, schema, f); }))\r\n          .then(fulfill, reject);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Check whether an individual table in the current database matches up with its corresponding Model.\r\n   * It will be created or modified as needed.\r\n   *\r\n   * @param {SQLTransaction} tx - a writeable transaction\r\n   * @param {Updraft.Schema} schema\r\n   * @param {object} f - a {@link Model} or other object that describes a table\r\n   * @return {Promise} A promise that resolves with no parameters once the table is up-to-date.\r\n   * @private\r\n   */\r\n  function syncTable(tx, schema, f) {\r\n    // execute CREATE TABLE statement\r\n    function createTable(name) {\r\n      var cols = [];\r\n      for (var col in f.columns) {\r\n        var attrs = f.columns[col];\r\n        var decl;\r\n        console.assert(attrs.type in columnType);\r\n        switch (attrs.type) {\r\n          case 'ptr':\r\n            console.assert(attrs.ref);\r\n            console.assert(attrs.ref.columns);\r\n            console.assert(attrs.ref.tableName);\r\n            console.assert(attrs.ref.key);\r\n            var foreignType = attrs.ref.columns[attrs.ref.key].type;\r\n            console.assert(foreignType in columnType);\r\n            decl = col + ' ' + columnType[foreignType];\r\n            cols.push(decl);\r\n            break;\r\n            \r\n          case 'list':\r\n            break;\r\n\r\n          default:\r\n            console.assert(attrs.type in columnType);\r\n            decl = col + ' ' + columnType[attrs.type];\r\n            if (f.key === col) {\r\n              decl += ' PRIMARY KEY';\r\n            }\r\n            cols.push(decl);\r\n        }\r\n      }\r\n      return self.exec(tx, 'CREATE ' + (f.temp ? 'TEMP ' : '') + 'TABLE ' + name + ' (' + cols.join(', ') + ')');\r\n    }\r\n\r\n    function dropTable(name) {\r\n      return self.exec(tx, 'DROP TABLE ' + name);\r\n    }\r\n\r\n    function createIndices(force) {\r\n      var p = Promise.resolve();\r\n      var toRemove = (f.tableName in schema) ? clone(schema[f.tableName]._indices) : {};\r\n      f.indices.forEach(function (index) {\r\n        var name = 'index_' + f.tableName + '__' + index.join('_');\r\n        var sql = 'CREATE INDEX ' + name + ' ON ' + f.tableName + ' (' + index.join(', ') + ')';\r\n        delete toRemove[name];\r\n        var create = true;\r\n        var drop = false;\r\n        if (schema[f.tableName] && schema[f.tableName]._indices && schema[f.tableName]._indices[name]) {\r\n          if (schema[f.tableName]._indices[name] === sql) {\r\n            create = false;\r\n          } else {\r\n            drop = true;\r\n          }\r\n        }\r\n\r\n        if (drop) {\r\n          p = p.then(self.exec(tx, 'DROP INDEX ' + name));\r\n        }\r\n        if (create || force) {\r\n          p = p.then(self.exec(tx, sql));\r\n        }\r\n      });\r\n\r\n      // delete orphaned indices\r\n      Object.keys(toRemove).forEach(function (name) {\r\n        p = p.then(self.exec(tx, 'DROP INDEX ' + name));\r\n      });\r\n      return p;\r\n    }\r\n\r\n    // check if table already exists\r\n    if (f.tableName in schema) {\r\n      if (f.recreate) {\r\n        return Promise.resolve()\r\n          .then(dropTable(f.tableName))\r\n          .then(createTable(f.tableName))\r\n          .then(createIndices(true));\r\n      } else {\r\n        //console.log(\"table \" + f.tableName + \" exists; checking columns\");\r\n        var columns = clone(schema[f.tableName]);\r\n        delete columns._indices;\r\n        delete columns._triggers;\r\n        var key;\r\n\r\n        var addedColumns = [];\r\n        var addedForeignKey = false;\r\n        for (key in f.columns) {\r\n          if (!(key in columns)) {\r\n            addedColumns.push(key);\r\n            if (f.columns[key].ref) {\r\n              addedForeignKey = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        var renamedColumns = clone(f.renamedColumns) || {};\r\n        for (key in Object.keys(renamedColumns)) {\r\n          if (!(key in columns)) {\r\n            delete renamedColumns[key];\r\n          }\r\n        }\r\n\r\n        var deletedColumns = Object.keys(columns).filter(function (col) {\r\n          return !(col in f.columns);\r\n        });\r\n\r\n        if (addedForeignKey || Object.keys(renamedColumns).length > 0 || deletedColumns.length > 0) {\r\n          // must recreate table and migrate data\r\n          var copyData = function (oldName, newName) {\r\n            var oldTableColumns = Object.keys(columns).filter(function (col) { return (col in f.columns) || (col in renamedColumns); });\r\n            var newTableColumns = oldTableColumns.map(function (col) { return (col in renamedColumns) ? renamedColumns[col] : col; });\r\n            var stmt = \"INSERT INTO \" + newName + \" (\" + newTableColumns.join(\", \") + \") \";\r\n            stmt += \"SELECT \" + oldTableColumns.join(\", \") + \" FROM \" + oldName + \";\";\r\n            return self.exec(tx, stmt);\r\n          };\r\n\r\n          var renameTable = function (oldName, newName) {\r\n            return self.exec(tx, 'ALTER TABLE ' + oldName + ' RENAME TO ' + newName);\r\n          };\r\n\r\n          var newTableName = 'new_' + f.tableName;\r\n          console.assert(!(newTableName in schema));\r\n\r\n          return Promise.resolve()\r\n            .then(createTable(newTableName))\r\n            .then(copyData(f.tableName, newTableName))\r\n            .then(dropTable(f.tableName))\r\n            .then(renameTable(newTableName, f.tableName))\r\n            .then(createIndices(true));\r\n\r\n        } else if (addedColumns.length > 0) {\r\n          // alter table, add columns\r\n          var p = Promise.resolve();\r\n          addedColumns.map(function (columnName) {\r\n            var attrs = f.columns[columnName];\r\n            console.assert(attrs.type in columnType);\r\n            var columnDecl = columnName + ' ' + columnType[attrs.type];\r\n            p = p.then(self.exec(tx, 'ALTER TABLE ' + f.tableName + ' ADD COLUMN ' + columnDecl));\r\n          });\r\n          return p\r\n            .then(createIndices());\r\n        } else {\r\n          // no table modification is required\r\n          return createIndices();\r\n        }\r\n      }\r\n    } else {\r\n      //console.log('creating table: ' + f.tableName);\r\n      return Promise.resolve()\r\n        .then(createTable(f.tableName))\r\n        .then(createIndices(true));\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Save all objects to database.  Atomic operation- all objects will be saved within the same transaction\r\n   * or nothing will be written.  Objects can be heterogeneous.\r\n   *\r\n   * @param {Updraft.Instance[]} objects\r\n   */\r\n  this.save = function (objects) {\r\n    objects.map(function (o) {\r\n      console.assert(('_' + o.model.key) in o, \"object must have a key\");\r\n    });\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      self.db.transaction(function (tx) {\r\n        function value(o, col) {\r\n          var val = o['_' + col];\r\n          if(typeof val === 'object') {\r\n            val = JSON.stringify(val);\r\n          }\r\n          return val;\r\n        }\r\n        \r\n        function insertLists(o, force) {\r\n          var changes = o.changes();\r\n          var f = o.model;\r\n          var promises = [];\r\n          Object.keys(f.columns)\r\n          .filter(function(col) {\r\n            return (f.columns[col].type === 'list') && (force || changes.indexOf(col) > -1);\r\n          })\r\n          .forEach(function(col) {\r\n            var ref = f.columns[col].ref;\r\n            var listTable = f.columns[col].listTable;\r\n            console.assert(ref);\r\n            console.assert(listTable);\r\n            var values = o['_' + col];\r\n            var key = o[f.key];\r\n            promises.push( self.exec(tx, 'DELETE FROM ' + listTable.tableName + ' WHERE ' + f.key + '=?', [ key ]) );\r\n            values.forEach(function(value) {\r\n              promises.push( self.exec(tx, 'INSERT INTO ' + listTable.tableName + ' (' + f.key + ', ' + col + ') VALUES (?, ?)', [key, value]) );\r\n            });\r\n          });\r\n          return Promise.all(promises);\r\n        }\r\n        \r\n        function insert(o, callback) {\r\n          var f = o.model;\r\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\r\n          var cols = Object.keys(f.columns).filter(isNotList);\r\n          var columns = cols.join(', ');\r\n          var values = cols.map(function () { return '?'; }).join(', ');\r\n          var args = cols.map(function(col) { return value(o, col); });\r\n          return self.exec(tx, 'INSERT OR IGNORE INTO ' + f.tableName + ' (' + columns + ') VALUES (' + values + ')', args, function (tx, results) {\r\n            var changes = results.rowsAffected !== 0;\r\n            return callback ? callback(changes) : changes;\r\n          });\r\n        }\r\n\r\n        function update(o, callback) {\r\n          var f = o.model;\r\n          var cols = o.changes();\r\n          var isNotList = function(col) { return f.columns[col].type !== 'list'; };\r\n          var isNotKey = function(col) { return col !== f.key; };\r\n          var assignments = cols\r\n            .filter(isNotList)\r\n            .filter(isNotKey)\r\n            .map(function (col) { return col + '=?'; })\r\n            .join(', ');\r\n          var values = cols\r\n            .filter(isNotList)\r\n            .filter(isNotKey)\r\n            .map(function(col) { return value(o, col); });\r\n          values.push(o['_' + f.key]); // for WHERE clause\r\n          return self.exec(tx, 'UPDATE OR IGNORE ' + f.tableName + ' SET ' + assignments + ' WHERE ' + f.key + '=?', values, function (tx, results) {\r\n            var changes = results.rowsAffected !== 0;\r\n            return callback ? callback(changes) : changes;\r\n          });\r\n        }\r\n\r\n        var upsert = function (o) {\r\n          var p;\r\n          if (o._isInDb) {\r\n            p = update(o, function (changed) { return changed ? insertLists(o, false) : insert(o); });\r\n          } else {\r\n            p = insert(o, function (changed) { return changed ? insertLists(o, true) : update(o); });\r\n          }\r\n          return p\r\n          .then(function (changed) {\r\n            console.assert(changed);\r\n            if(changed) {\r\n              o._changes = 0;\r\n              o._isInDb = true;\r\n            }\r\n          });\r\n        };\r\n\r\n        return Promise.all(objects.map(upsert)).then(resolve, reject);\r\n      });\r\n    });\r\n  };\r\n\r\n};\r\n\r\n\r\nUpdraft.Store = Store;\r\n\r\nmodule.exports = Updraft;\r\n\r\nif (window) {\r\n  window.Updraft = Updraft;\r\n}\r\n","'use strict';\n\nvar util = require('./util');\nvar Query = require('./query');\n\n\n\n/**\n * Instances of this type will have properties for all the columns defined in its {@link Model}.\n * You can add additional properties, but they will not be saved.  Object will track which properties have changed\n * since the last save.  Fields of type 'ptr' will return an object { [table's key]:[value], get: [function returning promise evaluating to object] }\n * \n *  Do not create objects of type Instance directly; instead create instances of a Model created by {@link Store#createClass}\n *\n * @see Model\n * @class\n * @example\n *  var store = new Updraft.Store();\n *  var Model = store.createClass(...);\n *  var i = new Model(); // i is an Instance\n */\nfunction Instance(props) {\n  var o = this;\n  o._changes = 0;\n  Object.keys(this.model.columns).forEach(function(col) {\n    if(o.model.columns[col].type === 'list') {\n      o['_' + col] = [];\n\n      // allow client to do object.field.push(otherobject); we'll transform it to object.field.push(otherobject.key())\n      o['_' + col].push = function() {\n        var args = Array.prototype.slice.call(arguments).map(function(arg) {\n          if(typeof arg === 'object') {\n            return arg.key();\n          } else {\n            return arg;\n          }\n        });\n        var array = o['_' + col];\n        var ret = Array.prototype.push.apply(array, args);\n        o[col] = array; // this will mark it dirty\n        return ret;\n      };\n    }\n  });\n  props = props || {};\n  for (var key in props) {\n    o[key] = props[key];\n  }\n}\n\n\n/**\n * Return the object's primary key's value\n *\n * @returns {string} Value of primary key\n * @example\n *  var x = new Class();\n *  x.id = 123;\n *  console.log(x.key());\n *  // -> '123'\n */\nInstance.prototype.key = function() {\n  var key = '_' + this.model.key;\n  console.assert(key in this);\n  return this[key];\n};\n\n\n\n/**\n * Get the fields that have been changed since the object was last loaded/saved\n *\n * @returns {string[]} Names of the fields that have changed\n * @example\n *  var x = new Class();\n *  x.foo = 'bar';\n *  console.log(x.changes());\n *  // -> ['foo']\n */\nInstance.prototype.changes = function () {\n  var changes = [];\n  var propIdx = 0;\n  for (var col in this.model.columns) {\n    var propMask = (1 << propIdx++);\n    if (this._changes & propMask) {\n      changes.push(col);\n    }\n  }\n  return changes;\n};\n\n\n\nvar addClassProperty = function(model, proto, col, propMask) {\n  var prop = '_' + col;\n\n  switch(model.columns[col].type) {\n    default:\n      Object.defineProperty(proto, col, {\n        get: function () {\n          return this[prop];\n        },\n        set: function (val) {\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'ptr':\n      Object.defineProperty(proto, col, {\n        get: function () {\n          var ref = this.model.columns[col].ref;\n          console.assert(ref.get);\n          var ret = {};\n          ret.ref = ref;\n          ret.own = this;\n          ret[ref.key] = this[prop];\n          ret.get = function () { return this.ref.get(this.own[prop]); };\n          return ret;\n        },\n        set: function (val) {\n          // allow client to do object.field = otherobject; we'll transform it to object.field = otherobject.key()\n          if(typeof val === 'object') {\n            val = val.key();\n          }\n          if (this[prop] !== val) {\n            this[prop] = val;\n            this._changes |= propMask;\n          }\n        }\n      });\n      break;\n\n    case 'list':\n      Object.defineProperty(proto, col, {\n        get: function() {\n          return this[prop];\n        },\n        set: function(val) {\n          // allow client to do object.field = [otherobject]; we'll transform it to object.field = [otherobject.key()]\n          val = val.map(function(arg) {\n            if(typeof arg === 'object') {\n              return arg.key();\n            } else {\n              return arg;\n            }\n          });\n          this[prop] = val;\n          this._changes |= propMask;\n        }\n      });\n      break;\n  }\n};\n\n\n\n/**\n * A class that you can use to create, save, and retrieve {@link Instance}s.\n * Do not create instances of type Model directly; instead use {@link Store#createClass}\n *\n * @property {string} tableName - the name of the table in which entities of this type will be stored.  Cannot begin with underscore.\n * @property {string} key - the name of the primary key for this table\n * @property {Updraft.columnType} keyType - the type of the primary key for this table\n * @property {Object} columns - an object describing the fields of objects of this type\n * @property {string} columns.key - name of the field\n * @property {object} columns.value\n * @property {Updraft.columnType} columns.value.type - 'int', 'bool', etc.\n * @property {bool} [columns.value.key=false] - set to true on the field that should be the primary key.  Only set one.\n * @property {bool} [columns.value.index=false] - create an index on this field\n * @property {Query} all - use to construct a query\n * @see ExampleModel\n * @class\n * @param {Store} store\n * @param {Updraft.ClassTemplate} templ\n * @example\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *  \n *  var x = new ExampleModel({keyField: 123});\n */\nfunction Model(store, templ) {\n  console.assert(store);\n  console.assert(templ);\n  console.assert(templ.tableName);\n  console.assert(templ.tableName[0] !== '_');\n  console.assert(templ.columns);\n  console.assert(Object.keys(templ.columns).length < 64);\n  console.assert(!('changes' in templ.columns));\n  console.assert(!('template' in templ.columns));\n  console.assert(!templ.renamedColumns || Object.keys(templ.renamedColumns).every(function (old) { return !(old in templ.columns); }));\n  \n  var ModelInstance = function() {\n    Instance.apply(this, arguments);\n  };\n\n  ModelInstance.prototype = Object.create(Instance.prototype);\n  ModelInstance.prototype.constructor = ModelInstance;\n  \n  var m = function(props) {\n    return new ModelInstance(props);\n  };\n\n  Object.setPrototypeOf(m, Model.prototype);\n  \n  Object.defineProperty(ModelInstance.prototype, 'model', { enumerable: true, value: m });\n  Object.defineProperty(ModelInstance.prototype, 'factory', { enumerable: true, value: m });\n\n  m.ModelInstance = ModelInstance;\n  \n  Object.defineProperty(m, 'store', { enumerable: true, value: store });\n  \n  Object.defineProperty(m, 'all', {\n    get: function() {\n      return new Query(this, this.store);\n    }\n  });\n\n  m.indices = [];\n\n  for (var key in templ) {\n    m[key] = util.clone(templ[key]);\n  }\n\n  m.key = null;\n  m.keyType = null;\n\n  var propIdx = 0;\n  for(var col in m.columns) {\n    if (m.columns[col].key) {\n      m.key = col;\n      m.keyType = m.columns[col].type;\n    }\n    if (m.columns[col].index) {\n      m.indices.push([col]);\n    }\n\n    var propMask = (1 << propIdx++);\n    addClassProperty(m, ModelInstance.prototype, col, propMask);\n    if (propIdx >= 63) {\n      throw new Error(\"class has too many columns- max 63\");\n    }\n  }\n\n  console.assert(m.key);\n\n  return m;\n}\n\n\n/**\n * Get a single object from database by its key\n *\n * @param id - value to find in table's primary key\n * @returns {Promise<Instance>} Promise that resolves with element or null if not found\n * @example\n *  Class.get(123).then(function(obj) {\n *    if(obj) {\n *      console.log('found object 123:', obj);\n *    } else {\n *      console.log('object 123 was not in db');\n *    }\n *  });\n */\nModel.prototype.get = function (id) {\n  return this.all.where(this.key, '=', id).get()\n  .then(function(results) {\n    console.assert(results.length < 2);\n    if(results.length === 0) {\n      return null;\n    } else {\n      return results[0];\n    }\n  });\n};\n\n\n/**\n * construct object from a database result row\n *\n * @param {SQLRow} row\n * @return instance of Model with fields initialized according to row, with _isInDb=true and no changes set\n * @private\n */\nModel.prototype.constructFromDb = function(row) {\n  var o = new this.ModelInstance();\n  for(var col in row) {\n    var val = row[col];\n    var _col = '_' + col;\n    switch(this.columns[col].type) {\n      case 'json':\n        o[_col] = JSON.parse(val);\n        break;\n      case 'list':\n        o[_col].push(val);\n        break;\n      default:\n        o[_col] = val;\n        break;\n    }\n  }\n\n  o._isInDb = true;\n  console.assert(o._changes === 0);\n  return o;\n};\n\n\n\n/**\n * Example class, an {@link Instance} returned by {@link Store#createClass}\n *\n * @class\n * @extends Instance\n * @name ExampleModel\n * @property {int} keyField - object's primary key, unique in the table\n * @property {string} stringField\n * @property {object} jsonField - can be any javascript type, object, or nesting of objects.  Will be \n *           stored stringified, so any shared properties will no longer be shared after reloading from db.\n * @property {int} indexedField - a regular integer field, but queries testing indexed fields will be faster.\n *           Doesn't have to be <tt>int</tt>- any field type can be indexed.\n * @property childField - a pseudo 'ChildClass' object.  Although you can assign to it, the object won't be available.\n *           That is, you will always need to call 'childField.get()' and wait for the promise, even if you just\n *           assigned to it.\n * @property {int} childField.id - the key of the child object pointed to.  Note that the member 'id' is because \n *           ChildClass's key is named 'id'; similarly the type is inherited from ChildClass's key type.  This \n *           is the only part of the reference that is stored on the object.\n * @property {list} listField - a searchable collection of objects\n * @see Updraft.ClassTemplate, Model\n * @example\n *  var ChildClass = store.createClass({\n *    tableName: 'childClass',\n *    columns: {\n *      id: { type: 'int', key: true },\n *      intField: { type: 'int', index: true }\n *    }\n *  });\n *  var ExampleModel = store.createClass({\n *    tableName: 'exampleModel',\n *    columns: {\n *      keyField: { type: 'int', key: true },\n *      stringField: { type: 'text' },\n *      jsonField: { type: 'json' },\n *      indexedField: { type: 'int', index: true },\n *      childField: { type: 'ptr', ref: ChildClass }\n *    }\n *  });\n *\n *  var child = new ChildClass({id: 321, intField: 456});\n *\n *  var x = new ExampleModel();\n *  x.keyField = 123;\n *  x.stringField = 'string example';\n *  x.jsonField = { x: 1, y: 'a', z: { foo: 'bar' } };\n *  console.log(x.changes());\n *  // -> ['keyField', 'stringField', 'jsonField']\n *\n *  // the following lines are exactly equivalent:\n *  x.childField = child;\n *  x.childField = child.id;\n *  x.childField = 321;\n *\n *  console.log(x.childField.id); // -> 321\n *\n *  x.childField.get().then(function(c) {\n *    // child was never saved, so c is null, unless there was\n *    // already a ChildClass with id=321 in the db');\n *  });\n *\n *  // ... assume more objects have been created and saved ...\n *\n *  ExampleModel.all.where('childField.intField', '=', 456).get()\n *  .then(function(results) {\n *    // results is an array containing (a copy of) x and anything\n *    // else that has the same \n *  });\n */\n\n\nmodule.exports = Model;\n","'use strict';\n\n\n/**\n * Do not construct objects of type Query directly- instead, use {@link Model}.all\n * @class\n * @constructor\n * @param {Model} model\n * @param {Store} store\n */\nvar Query = function(model, store) {\n  console.assert(model);\n  console.assert(store);\n  this._model = model;\n  this._store = store;\n  this._justCount = false;\n  this._tables = [model.tableName];\n  this._columns = [];\n  this._conditions = [];\n  this._order = undefined;\n  this._asc = true;\n  this._nocase = false;\n\n  // add child tables\n  for(var col in model.columns) {\n    if(model.columns[col].type !== 'list') {\n      this._columns.push(model.tableName + '.' + col);\n    }\n  }\n};\n\n\nQuery.prototype.all = function() {\n  return this.get();\n};\n\n\nQuery.prototype.addCondition = function(conj, col, op, val) {\n  var fields = col.split(/\\./);\n    var f = this._model;\n    for(var i=0; i<fields.length - 1; i++) {\n      var field = fields[i];\n      console.assert(field in f.columns);\n      var ref = f.columns[field].ref;\n      console.assert(ref);\n      if(this._tables.indexOf(ref.tableName)) {\n        this._tables.push(ref.tableName);\n        this._conditions.push({\n          conj: 'AND',\n          col: f.tableName + '.' + field,\n          op: '=',\n          val: ref.tableName + '.' + ref.key\n        });\n      }\n      f = ref;\n    }\n    this._conditions.push({\n      conj: conj,\n      col: f.tableName + '.' + fields[fields.length - 1],\n      op: op,\n      val: '?',\n      arg: val\n    });\n  return this;\n};\n\n\n/**\n * Adds an 'AND' condition to the query\n *\n * @method\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#or\n * @example\n *  return Class.all.where('col2', '>', 10).and('col2', '<', 30).get();\n *  // -> SELECT ... WHERE col2 > 10 AND col2 < 30\n */\nQuery.prototype.and = function(col, op, val) {\n  return this.addCondition('AND', col, op, val);\n};\n\n\n/**\n * alias for {@link Query#and}\n *\n * @method\n * @return {Query}\n * @example\n *  return Class.all.where('col2', '>', 10).get();\n */\nQuery.prototype.where = Query.prototype.and;\n\n\n/**\n * Adds an 'OR' condition to the query\n *\n * @param {string} col - column field to match on\n * @param {string} op - SQLite binary [operator]{@link https://www.sqlite.org/lang_expr.html}\n * @param val - value to match against {@linkcode col}\n * @return {Query}\n * @see Query#and\n * @example\n *  return Class.all.where('col2', '=', 10).and('col2', '=', 30).get();\n *  // -> SELECT ... WHERE col2 = 10 OR col2 = 30\n */\nQuery.prototype.or = function(col, op, val) {\n  return this.addCondition('OR', col, op, val);\n};\n\n\n/**\n * Sort the results by specified field\n *\n * @param {string} col - column to sort by\n * @param {bool} [asc=true] - sort ascending (true, default) or descending (false)\n * @return {Query}\n * @see Query#nocase\n * @example\n *  return Class.all.order('x').get();\n *  // -> SELECT ... ORDER BY x\n */\nQuery.prototype.order = function(col, asc) {\n  this._order = col;\n  if(typeof asc !== 'undefined') {\n    this._asc = asc;\n  }\n  return this;\n};\n\n/**\n * Changes the match collation to be case-insensitive.  Only applies to result sorting, as 'LIKE' is \n * always case-insensitive\n *\n * @return {Query}\n * @see Query#order\n * @example\n *  return Class.all.order('x').nocase().get();\n *  // -> SELECT ... ORDER BY x COLLATE NOCASE\n */\nQuery.prototype.nocase = function() {\n  this._nocase = true;\n  return this;\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the count of objects that match\n *\n * @return {Promise<int>}\n * @see Query#get\n * @example\n *  return Class.all.count()\n *  .then(function(count) { console.log(count + \" objects\") });\n *  // -> SELECT COUNT(*) FROM ...\n */\nQuery.prototype.count = function() {\n  this._justCount = true;\n  return this.get();\n};\n\n\n/**\n * Executes the query, returning a promise resolving with the array of objects that match any conditions\n * set on the Query\n *\n * @return {Promise<Instance[]>}\n * @see Query#count\n * @example\n *  return Class.all.where('x', '>', 0).get();\n *  // -> SELECT ... WHERE x > 0\n */\nQuery.prototype.get = function() {\n  var countProp = 'COUNT(*)';\n  var stmt = 'SELECT ';\n  var model = this._model;\n  if(this._justCount) {\n    stmt += countProp;\n  } else {\n    stmt += this._columns.join(', ');\n  }\n  stmt += ' FROM ' + this._tables.join(', ');\n  var args = [];\n  for(var i=0; i<this._conditions.length; i++) {\n    var cond = this._conditions[i];\n    stmt += (i === 0) ? ' WHERE ' : (' ' + cond.conj + ' ');\n    stmt += cond.col + ' ' + cond.op + ' ' + cond.val;\n    if('arg' in cond) {\n      args.push(cond.arg);\n    }\n  }\n  if(this._order) {\n    stmt += ' ORDER BY ' + this._order;\n    stmt += (this._nocase ? ' COLLATE NOCASE' : '');\n    stmt += (this._asc ? ' ASC' : ' DESC');\n  }\n\n  var objects = [];\n  var query = this;\n  return this._store.execRead(stmt, args, function (tx, results) {\n    if(query._justCount) {\n      return results.rows.item(0)[countProp];\n    }\n    for (var i = 0; i < results.rows.length; i++) {\n      var o = model.constructFromDb(results.rows.item(i));\n      objects.push(o);\n    }\n    return Promise.all(objects.map(function(o) {\n      return Promise.all(\n        Object.keys(model.columns)\n        .filter(function(col) {\n          return (model.columns[col].type === 'list');\n        })\n        .map(function(col) {\n          var listTable = model.columns[col].listTable;\n          console.assert(listTable);\n          var key = o.key();\n          var s = 'SELECT ' + col;\n          s += ' FROM ' + listTable.tableName;\n          s += ' WHERE ' + query._model.key + ' = ?';\n          return query._store.exec(tx, s, [key], function(tx, results) {\n            for(var i=0; i<results.rows.length; i++) {\n              var row = results.rows.item(i);\n              o['_' + col].push(row[col]);\n            }\n            o._changes = 0;\n          });\n        })\n      );\n    }))\n    .then(function() {\n      return objects;\n    });\n  });\n};\n\n\nmodule.exports = Query;\n","'use strict';\n\nfunction startsWith(str, val) {\n  return str.lastIndexOf(val, 0) === 0;\n}\n\n\nfunction clone(obj) {\n  var copy;\n\n  // Handle the 3 simple types, and null or undefined\n  if (null === obj || \"object\" !== typeof obj) {\n    return obj;\n  }\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\n    for (var i = 0, len = obj.length; i < len; i++) {\n      copy[i] = clone(obj[i]);\n    }\n    return copy;\n  }\n\n  // Handle Object\n  if (obj instanceof Object) {\n    copy = {};\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = clone(obj[attr]);\n      }\n    }\n    return copy;\n  }\n\n  throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\n\nfunction inherits( child, Parent ) { \n  if (Parent.constructor == Function) {\n    //Normal Inheritance \n    child.prototype = Object.create(Parent.prototype);\n    child.prototype.constructor = child;\n    child.prototype.parent = Parent.prototype;\n  } else {\n    //Pure Virtual Inheritance \n    child.prototype = Parent;\n    child.prototype.constructor = child;\n    child.prototype.parent = Parent;\n  }\n\n  // inherit class methods\n//  for (var prop in Parent) {\n//    //if (typeof(Parent[prop]) === 'function' ) {\n//      child[prop] = Parent[prop];\n//    //}\n//  }\n  \n  return child;\n} \n\nmodule.exports.startsWith = startsWith;\nmodule.exports.clone = clone;\nmodule.exports.inherits = inherits;\n"]}